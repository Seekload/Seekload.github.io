<!doctype html>
<html lang="zh-CN">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4b79e198f0e43ade55032d4bf11860a4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.53" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Golang语言面试题（精编263道题），包含解析！！！ | Seekload&#39;s Blog</title>
    <meta property="og:title" content="Golang语言面试题（精编263道题），包含解析！！！ - Seekload&#39;s Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2021-02-28T10:38:26&#43;08:00">
        
        
    <meta property="article:modified_time" content="2021-02-28T10:38:26&#43;08:00">
        
    <meta name="Keywords" content="">
    <meta name="description" content="Golang语言面试题（精编263道题），包含解析！！！">
        
    <meta name="author" content="Seekload">
    <meta property="og:url" content="https://seekload.net/2021/02/28/interview-question.html">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://seekload.net">
                        Seekload&#39;s Blog
                    </a>
                
                <p class="description">专注于分享 Go 语言、职场心得和生活感悟</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://seekload.net">首页</a>
                    
                    <a  href="https://seekload.net/archives/" title="归档">归档</a>
                    
                    <a  href="https://seekload.net/golang100/" title="Go语言知识站">Go语言知识站</a>
                    
                    <a  href="https://seekload.net/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Golang语言面试题（精编263道题），包含解析！！！</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2021年2月28日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://seekload.net/categories/%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a></span>
                            
                                <span class="meta-category"><a href="https://seekload.net/categories/golang">Golang</a></span>
                            
                        </div>
                        
                        <div class="post-meta">
                            <span >
                                <span>|</span>
                                字数:36622
                            </span>
                        </div>
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            

<p>Hi：<br>
亲爱的读者朋友，你好！我是 Seekload，很多公号的老读者都知道，19 年的时候，公号连续 120 天发布了关于 Golang  面试题相关的文章，这些题目包含很多 Go 语言易错点、常见的坑和值得关注的点，
认真追完这一系列的同学都说收获非常大！说实话，其实这不仅仅是一份面试题，还是一份可以拿来查漏补缺的 Go 语言参考资料。</p>

<p>虽然公号后台已经对这 120 篇文章做了汇总，但是需要点击跳转，看起来还是不方便，所以贴心的四哥将所有题目汇总在一块，做成了 pdf 文档（获取方式在下方），总共有 263 道题。这些题目大部分参考了网上优秀的资料，比如 <a href="https://studygolang.com/">Go语言中文网</a>、tonybai.com、《Go语言101》等，参考的资料太多，就不一一列举了，但都表示特别感谢。题目后面也有出处以及相关的阅读资料。</p>

<p>因为题目和解析都是我一个人整理，再加上题目也比较多，难免会有疏漏和不足的地方，还望见谅！大家看题目过程中也肯定会遇到不理解的地方，所以特意建了微信读者群，针对文档的错误之处或者有疑惑的知识点都可以在群里反馈，我会免费给大解答。大家可以加我微信 seekload01，备注【面试题】，我会拉你进群，加过我微信的同学也需要单独私我。</p>

<p>最后，祝愿大家 Go 语言学习之路能一路精进，早日升职加薪！</p>

<p>pdf 获取方式：<br>
扫描右侧二维码，在公号后台回复关键字【面试题】！<br>
扫描右侧二维码，在公号后台回复关键字【面试题】！<br>
扫描右侧二维码，在公号后台回复关键字【面试题】！<br></p>

<h3 id="第-1-天">第 1 天</h3>

<p>1.下面这段代码输出的内容</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println(&quot;打印前&quot;) }()
    defer func() { fmt.Println(&quot;打印中&quot;) }()
    defer func() { fmt.Println(&quot;打印后&quot;) }()

    panic(&quot;触发异常&quot;)
}
</code></pre>

<p>答案：</p>

<pre><code class="language-go">打印后
打印中
打印前
panic: 触发异常
</code></pre>

<p>解析：defer 的执行顺序是后进先出。当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic。</p>

<h3 id="第-2-天">第 2 天</h3>

<p>1.下面这段代码输出什么，说明原因。</p>

<pre><code class="language-go">func main() {

	slice := []int{0,1,2,3}
	m := make(map[int]*int)

	for key,val := range slice {
		m[key] = &amp;val
	}

	for k,v := range m {
		fmt.Println(k,&quot;-&gt;&quot;,*v)
	}
}

</code></pre>

<p>参考答案：</p>

<pre><code class="language-go">0 -&gt; 3
1 -&gt; 3
2 -&gt; 3
3 -&gt; 3
</code></pre>

<p>解析：这是新手常会犯的错误写法，for range 循环的时候会<strong>创建每个元素的副本，而不是元素的引用</strong>，所以 m[key] = &amp;val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3.</p>

<p>正确的写法：</p>

<pre><code class="language-go">func main() {

	slice := []int{0,1,2,3}
	m := make(map[int]*int)

	for key,val := range slice {
		value := val
		m[key] = &amp;value
	}

	for k,v := range m {
		fmt.Println(k,&quot;===&gt;&quot;,*v)
	}
}
</code></pre>

<p>扩展题目</p>

<pre><code class="language-go">type Test struct {
	name string
}

func (this *Test) Point(){
	fmt.Println(this.name)
}


func main() {

	ts := []Test{
		{&quot;a&quot;},
		{&quot;b&quot;},
		{&quot;c&quot;},
	}

	for _,t := range ts {
		//fmt.Println(reflect.TypeOf(t))
		defer t.Point()
	}
	
}
</code></pre>

<p>参考：
<a href="https://blog.csdn.net/idwtwt/article/details/87378419">https://blog.csdn.net/idwtwt/article/details/87378419</a></p>

<h3 id="第-3-天">第 3 天</h3>

<p>1.下面两段代码输出什么。</p>

<pre><code class="language-go">// 1.
func main() {
    s := make([]int, 5)
    s = append(s, 1, 2, 3)
    fmt.Println(s)
}

// 2.
func main() {
	s := make([]int,0)
	s = append(s,1,2,3,4)
	fmt.Println(s)
}
</code></pre>

<p>2.下面这段代码有什么缺陷</p>

<pre><code class="language-go">func funcMui(x,y int)(sum int,error){
	return x+y,nil
}
</code></pre>

<p>答案：第二个返回值没有命名。
解析：
在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。</p>

<p>3.new() 与 make() 的区别。</p>

<p>new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。</p>

<p>new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。
适用于值类型，如数组、结构体等。</p>

<p>make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.</p>

<h3 id="第-4-天">第 4 天</h3>

<p>1.下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。</p>

<pre><code class="language-go">func main() {
	list := new([]int)
	list = append(list, 1)
	fmt.Println(list)
}
</code></pre>

<p>参考答案：不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。</p>

<p>2.下面这段代码能否通过编译，如果可以，输出什么？</p>

<pre><code class="language-go">func main() {
	s1 := []int{1, 2, 3}
	s2 := []int{4, 5}
	s1 = append(s1, s2)
	fmt.Println(s1)
}
</code></pre>

<p>参考答案：不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。</p>

<p>3.下面这段代码能否通过编译，如果可以，输出什么？</p>

<pre><code class="language-go">var(
	size := 1024
	max_size = size*2
)

func main() {
	fmt.Println(size,max_size)
}
</code></pre>

<p>参考答案：不能通过编译。</p>

<p>参考解析：这道题的主要知识点是变量声明的简短模式，形如：x := 100.
但这种声明方式有限制：
1. 必须使用显示初始化；
2. 不能提供数据类型，编译器会自动推导；
3. 只能在函数内部使用简短模式；</p>

<h3 id="第-5-天">第 5 天</h3>

<p>1.下面这段代码能否通过编译？不能的话，原因是什么？如果通过，输出什么？</p>

<pre><code class="language-go">func main() {
	sn1 := struct {
		age  int
		name string
	}{age: 11, name: &quot;qq&quot;}
	sn2 := struct {
		age  int
		name string
	}{age: 11, name: &quot;qq&quot;}

	if sn1 == sn2 {
		fmt.Println(&quot;sn1 == sn2&quot;)
	}

	sm1 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{&quot;a&quot;: &quot;1&quot;}}
	sm2 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{&quot;a&quot;: &quot;1&quot;}}

	if sm1 == sm2 {
		fmt.Println(&quot;sm1 == sm2&quot;)
	}
}
</code></pre>

<p>参考答案：编译不通过 invalid operation: sm1 == sm2</p>

<p>参考解析：
这道题目考的是<strong>结构体的比较</strong>：
1. 结构体只能比较是否相等，但是不能比较大小。
2. 相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关，sn3 与 sn1 就是不同的结构体；</p>

<pre><code class="language-go">    sn3:= struct {
		name string
		age  int
	}{age:11,name:&quot;qq&quot;}
</code></pre>

<ol>
<li>如果 struct 的所有成员都可以比较，则该 struct 就可以<strong>通过 == 或 != 进行比较</strong>是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等；</li>
</ol>

<p>那什么是可比较的呢，常见的有 bool、数值型、string、指针、数组等，像切片、map、函数等是不能比较的。  具体可以参考 Go 说明文档。<a href="https://golang.org/ref/spec#Comparison_operators">https://golang.org/ref/spec#Comparison_operators</a></p>

<h3 id="第-6-天">第 6 天</h3>

<p>1.通过指针变量 p 访问其成员变量 name，有哪几种方式？
- A.p.name
- B.(&amp;p).name
- C.(*p).name
- D.p-&gt;name</p>

<p>参考答案：AC
参考解析：&amp; 取址运算符，* 指针解引用。</p>

<p>2.下面这段代码能否通过编译？如果通过，输出什么？</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type MyInt1 int
type MyInt2 = int

func main() {
	var i int =0
	var i1 MyInt1 = i 
	var i2 MyInt2 = i
	fmt.Println(i1,i2)
}
</code></pre>

<p>参考答案：编译不通过，cannot use i (type int) as type MyInt1 in assignment</p>

<p>参考解析：这道题考的是类型别名与类型定义的区别。</p>

<p>第 5 行代码是基于类型 int 创建了新类型 MyInt1，第 6 行代码是创建了 int 的类型别名 MyInt2，注意类型别名的定义时 = 。所以，第 10 行代码相当于是将 int 类型的变量赋值给 MyInt1 类型的变量，Go 是强类型语言，编译当然不通过；而 MyInt2 只是 int 的别名，本质上还是 int，可以赋值。</p>

<p>第 10 行代码的赋值可以使用强制类型转化 var i1 MyInt1 = MyInt1(i).</p>

<h3 id="第-7-天">第 7 天</h3>

<p>1.关于字符串连接，下面语法正确的是？</p>

<ul>
<li>A. str := &lsquo;abc&rsquo; + &lsquo;123&rsquo;</li>
<li>B. str := &ldquo;abc&rdquo; + &ldquo;123&rdquo;</li>
<li>C. str := &lsquo;123&rsquo; + &ldquo;abc&rdquo;</li>
<li>S. fmt.Sprintf(&ldquo;abc%d&rdquo;, 123)</li>
</ul>

<p>参考答案：BD</p>

<p>参考解析：考的知识点是字符串连接。除了以上两种连接方式，还有 strings.Join()、buffer.WriteString()等。</p>

<p>2.下面这段代码能否编译通过？如果可以，输出什么？</p>

<pre><code class="language-go">const (
	x = iota
	_
	y
	z = &quot;zz&quot;
	k 
	p = iota
)

func main()  {
	fmt.Println(x,y,z,k,p)
}
</code></pre>

<p>参考答案：编译通过，输出：0 2 zz zz 5</p>

<p>参考解析：知识点 iota。
参考 <a href="https://www.cnblogs.com/zsy/p/5370052.html">https://www.cnblogs.com/zsy/p/5370052.html</a></p>

<p>3.下面赋值正确的是()
- A. var x = nil
- B. var x interface{} = nil
- C. var x string = nil
- D. var x error = nil</p>

<p>参考答案及解析：BD。这道题考的知识点是 nil。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看它的源码就知道，所以 D 是对的。</p>

<pre><code class="language-go">type error interface {
	Error() string
}
</code></pre>

<h3 id="第-8-天">第 8 天</h3>

<p>1.关于init函数，下面说法正确的是()
- A. 一个包中，可以包含多个 init 函数；
- B. 程序编译时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数；
- C. main 包中，不能有 init 函数；
- D. init 函数可以被其他函数调用；</p>

<p>参考答案及解析：AB。关于 init() 函数有几个需要注意的地方：</p>

<ol>
<li>init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;</li>
<li>一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数；</li>
<li>同一个包中多个 init() 函数的执行顺序没有明确定义，<strong>但是不同包的init函数是根据包导入的依赖关系决定的</strong>;</li>
<li>init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误;</li>
<li>一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；</li>
<li>引入包，不可出现死循坏。即A import B,B import A，这种情况编译失败；</li>
</ol>

<p>2.下面这段代码输出什么以及原因？</p>

<pre><code class="language-go">func hello() []string {  
    return nil
}

func main() {  
    h := hello
    if h == nil {
        fmt.Println(&quot;nil&quot;)
    } else {
        fmt.Println(&quot;not nil&quot;)
    }
}
</code></pre>

<ul>
<li>A. nil</li>
<li>B. not nil</li>
<li>C. compilation error<br /></li>
</ul>

<p>答案及解析：B。这道题目里面，是将 hello() 赋值给变量 h，而不是函数的返回值，所以输出 not nil。</p>

<p>3.下面这段代码能否编译通过？如果可以，输出什么？</p>

<pre><code class="language-go">func GetValue() int {
	return 1
}

func main() {
	i := GetValue()
	switch i.(type) {
	case int:
		println(&quot;int&quot;)
	case string:
		println(&quot;string&quot;)
	case interface{}:
		println(&quot;interface&quot;)
	default:
		println(&quot;unknown&quot;)
	}
}
</code></pre>

<p>答案及解析：编译失败。考点：类型选择，类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型选择。</p>

<h3 id="第-9-天">第 9 天</h3>

<p>1.关于 channel，下面语法正确的是（）</p>

<ul>
<li>A. var ch chan int</li>
<li>B. ch := make(chan int)</li>
<li>C. &lt;- ch</li>
<li>D. ch &lt;-</li>
</ul>

<p>参考答案及解析：ABC。A、B都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。</p>

<p>2.下面这段代码输出什么？
- A.0
- B.1
- C.Compilation error</p>

<pre><code class="language-go">type person struct {  
    name string
}

func main() {  
    var m map[person]int
    p := person{&quot;mike&quot;}
    fmt.Println(m[p])
}
</code></pre>

<p>参考答案及解析：A。打印一个 map 中不存在的值时，返回元素类型的零值。这个例子中，m 的类型是 map[person]int，因为 m 中不存在 p，所以打印 int 类型的零值，即 0。</p>

<p>3.下面这段代码输出什么？
- A.18
- B.5
- C.Compilation error</p>

<pre><code class="language-go">func hello(num ...int) {  
    num[0] = 18
}

func main() {  
    i := []int{5, 6, 7}
    hello(i...)
    fmt.Println(i[0])
}
</code></pre>

<p>参考答案及解析：18。知识点：可变函数。可以看下之前发过的文章。</p>

<h3 id="第-10-天">第 10 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {  
    a := 5
    b := 8.1
    fmt.Println(a + b)
}
</code></pre>

<ul>
<li>A.13.1<br /></li>
<li>B.13</li>
<li>C.compilation error<br /></li>
</ul>

<p>参考答案及解析：C。a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">package main

import (  
    &quot;fmt&quot;
)

func main() {  
    a := [5]int{1, 2, 3, 4, 5}
    t := a[3:4:4]
    fmt.Println(t[0])
}
</code></pre>

<ul>
<li>A.3</li>
<li>B.4</li>
<li>C.compilation error<br /></li>
</ul>

<p>参考答案及解析：B。<br></p>

<p>知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。</p>

<p>假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：<br>
<strong>长度：j-i，容量：k-i</strong></p>

<p>截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：<strong>j-i、k-i。</strong></p>

<p>所以例子中，切片 t 为 [4]，长度和容量都是 1。</p>

<p>3.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	a := [2]int{5, 6}
	b := [3]int{5, 6}
	if a == b {
		fmt.Println(&quot;equal&quot;)
	} else {
		fmt.Println(&quot;not equal&quot;)
	}
}
</code></pre>

<ul>
<li>A. compilation error<br /></li>
<li>B. equal<br /></li>
<li>C. not equal<br /></li>
</ul>

<p>参考答案及解析：A。Go 中的数组是值类型，可比较，另外一方面，数组的长度也是数组类型的组成部分，所以 a 和 b 是不同的类型，是不能比较的，所以编译错误。</p>

<h3 id="第-11-天">第 11 天</h3>

<p>1.关于 cap() 函数的适用类型，下面说法正确的是()
- A. array
- B. slice
- C. map
- D. channel</p>

<p>参考答案及解析：ABD。知识点：cap()，cap() 函数不适用 map。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {  
    var i interface{}
    if i == nil {
        fmt.Println(&quot;nil&quot;)
        return
    }
    fmt.Println(&quot;not nil&quot;)
}
</code></pre>

<ul>
<li>A. nil</li>
<li>B. not nil</li>
<li>C. compilation error<br /></li>
</ul>

<p>参考答案及解析：A。当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。</p>

<p>3.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {  
    s := make(map[string]int)
    delete(s, &quot;h&quot;)
    fmt.Println(s[&quot;h&quot;])
}
</code></pre>

<ul>
<li>A. runtime panic</li>
<li>B. 0</li>
<li>C. compilation error</li>
</ul>

<p>参考答案及解析：B。删除 map 不存在的键值对时，不会报错，相当于没有任何作用；获取不存在的减值对时，返回值类型对应的零值，所以返回 0。</p>

<h3 id="第-12-天">第 12 天</h3>

<p>1.下面属于关键字的是()</p>

<ul>
<li>A.func</li>
<li>B.struct</li>
<li>C.class</li>
<li>D.defer</li>
</ul>

<p>参考答案及解析：ABD。知识点：Go 语言的 25 个关键字。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {  
    i := -5
    j := +5
    fmt.Printf(&quot;%+d %+d&quot;, i, j)
}
</code></pre>

<ul>
<li>A. -5 +5</li>
<li>B. +5 +5</li>
<li>C. 0  0</li>
</ul>

<p>参考答案及解析：A。<code>%d</code>表示输出十进制数字，<code>+</code>表示输出数值的符号。这里不表示取反。</p>

<p>3.下面这段代码输出什么？</p>

<pre><code class="language-go">type People struct{}

func (p *People) ShowA() {
	fmt.Println(&quot;showA&quot;)
	p.ShowB()
}
func (p *People) ShowB() {
	fmt.Println(&quot;showB&quot;)
}

type Teacher struct {
	People
}

func (t *Teacher) ShowB() {
	fmt.Println(&quot;teacher showB&quot;)
}

func main() {
	t := Teacher{}
	t.ShowB()
}
</code></pre>

<p>参考答案及解析：teacher showB。知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。</p>

<h3 id="第-13-天">第 13 天</h3>

<p>1.定义一个包内全局字符串变量，下面语法正确的是（）</p>

<ul>
<li>A. var str string</li>
<li>B. str := &ldquo;&rdquo;</li>
<li>C. str = &ldquo;&rdquo;</li>
<li>D. var str = &ldquo;&rdquo;</li>
</ul>

<p>参考答案及解析：AD。B 只支持局部变量声明；C 是赋值，str 必须在这之前已经声明；</p>

<p>2.下面这段代码输出什么?</p>

<pre><code class="language-go">func hello(i int) {  
    fmt.Println(i)
}
func main() {  
    i := 5
    defer hello(i)
    i = i + 10
}
</code></pre>

<p>参考答案及解析：5。这个例子中，hello() 函数的参数在执行 defer 语句的时候会保存一份副本，在实际调用 hello() 函数时用，所以是 5.</p>

<p>3.下面这段代码输出什么？</p>

<pre><code class="language-go">type People struct{}

func (p *People) ShowA() {
	fmt.Println(&quot;showA&quot;)
	p.ShowB()
}
func (p *People) ShowB() {
	fmt.Println(&quot;showB&quot;)
}

type Teacher struct {
	People
}

func (t *Teacher) ShowB() {
	fmt.Println(&quot;teacher showB&quot;)
}

func main() {
	t := Teacher{}
	t.ShowA()
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">showA
showB
</code></pre>

<p>知识点：结构体嵌套。这道题可以结合第 12 天的第三题一起看，Teacher 没有自己 ShowA()，所以调用内部类型 People 的同名方法，需要注意的是第 5 行代码调用的是 People 自己的 ShowB 方法。</p>

<h3 id="第-14-天">第 14 天</h3>

<p>1.下列选项正确的是？</p>

<pre><code class="language-go">func main() {
	str := &quot;hello&quot;
	str[0] = 'x'
	fmt.Println(str)
}
</code></pre>

<ul>
<li>A. hello</li>
<li>B. xello</li>
<li>C. compilation error</li>
</ul>

<p>参考代码及解析：C。知识点：常量，Go 语言中的字符串是只读的。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func incr(p *int) int {
	*p++
	return *p
}

func main() {
	p :=1
	incr(&amp;p)
	fmt.Println(p)
}
</code></pre>

<ul>
<li>A. 1</li>
<li>B. 2</li>
<li>C. 3</li>
</ul>

<p>参考答案及解析：B。知识点：指针，incr() 函数里的 p 是 <code>*int</code> 类型的指针，指向的是 main() 函数的变量 p 的地址。 第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。</p>

<p>3.对 add() 函数调用正确的是？</p>

<pre><code class="language-go">func add(args ...int) int {

	sum := 0
	for _, arg := range args {
		sum += arg
	}
	return sum
}
</code></pre>

<ul>
<li>A. add(1, 2)</li>
<li>B. add(1, 3, 7)</li>
<li>C. add([]int{1, 2})</li>
<li>D. add([]int{1, 3, 7}&hellip;)</li>
</ul>

<p>参考答案及解析：ABD。知识点：可变函数。</p>

<h3 id="第-15-天">第 15 天</h3>

<p>1.下面代码下划线处可以填入哪个选项？</p>

<pre><code class="language-go">func main() {
	var s1 []int
	var s2 = []int{}
	if __ == nil {
		fmt.Println(&quot;yes nil&quot;)
	}else{
		fmt.Println(&quot;no nil&quot;)
	}
}
</code></pre>

<ul>
<li>A. s1</li>
<li>B. s2</li>
<li>C. s1、s2 都可以</li>
</ul>

<p>参考答案及解析：A。知识点：nil 切片和空切片。nil 切片和 nil 相等，一般用来表示一个不存在的切片；空切片和 nil 不相等，表示一个空的集合。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {  
    i := 65
    fmt.Println(string(i))
}
</code></pre>

<ul>
<li>A. A</li>
<li>B. 65</li>
<li>C. compilation error</li>
</ul>

<p>参考答案及解析：A。UTF-8 编码中，十进制数字 65 对应的符号是 A。</p>

<p>3.下面这段代码输出什么？</p>

<pre><code class="language-go">type A interface {
	ShowA() int
}

type B interface {
	ShowB() int
}

type Work struct {
	i int
}

func (w Work) ShowA() int {
	return w.i + 10
}

func (w Work) ShowB() int {
	return w.i + 20
}

func main() {
	c := Work{3}
	var a A = c
	var b B = c
	fmt.Println(a.ShowA())
	fmt.Println(b.ShowB())
}
</code></pre>

<p>参考答案及解析：13 23。知识点：接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23。</p>

<h3 id="第-16-天">第 16 天</h3>

<p>1.切片 a、b、c 的长度和容量分别是多少？</p>

<pre><code class="language-go">func main() {

	s := [3]int{1, 2, 3}
	a := s[:0]
	b := s[:2]
	c := s[1:2:cap(s)]
}
</code></pre>

<p>参考答案及解析：a、b、c 的长度和容量分别是 0 3、2 3、1 2。知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的<strong>切片长度和容量计算方法是 j-i、l-i</strong>。操作符 [i:j:k]，k 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的<strong>切片长度和容量计算方法是 j-i、k-i</strong>。</p>

<p>2.下面代码中 A B 两处应该怎么修改才能顺利编译？</p>

<pre><code class="language-go">func main() {
	var m map[string]int        //A
	m[&quot;a&quot;] = 1
	if v := m[&quot;b&quot;]; v != nil {  //B
		fmt.Println(v)
	}
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">func main() {
	m := make(map[string]int)
	m[&quot;a&quot;] = 1
	if v,ok := m[&quot;b&quot;]; ok {
		fmt.Println(v)
	}
}
</code></pre>

<p>在 A 处只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。</p>

<p>B 处，<code>v,k := m[&quot;b&quot;]</code> 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。</p>

<p>3.下面代码输出什么？</p>

<pre><code class="language-go">type A interface {
	ShowA() int
}

type B interface {
	ShowB() int
}

type Work struct {
	i int
}

func (w Work) ShowA() int {
	return w.i + 10
}

func (w Work) ShowB() int {
	return w.i + 20
}

func main() {
	c := Work{3}
	var a A = c
	var b B = c
	fmt.Println(a.ShowB())
	fmt.Println(b.ShowA())
}
</code></pre>

<ul>
<li>A. 23 13</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：B。知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。看下编译错误：</p>

<pre><code class="language-go">a.ShowB undefined (type A has no field or method ShowB)
b.ShowA undefined (type B has no field or method ShowA)
</code></pre>

<h3 id="第-17-天">第 17 天</h3>

<p>1.下面代码中，x 已声明，y 没有声明，判断每条语句的对错。</p>

<pre><code class="language-go">1. x, _ := f()
2. x, _ = f()
3. x, y := f()
4. x, y = f()
</code></pre>

<p>参考答案及解析：错、对、对、错。知识点：变量的声明。1.错，x 已经声明，不能使用 :=；2.对；3.对，当多值赋值时，:= 左边的变量无论声明与否都可以；4.错，y 没有声明。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func increaseA() int {
	var i int
	defer func() {
		i++
	}()
	return i
}

func increaseB() (r int) {
	defer func() {
		r++
	}()
	return r
}

func main() {
	fmt.Println(increaseA())
	fmt.Println(increaseB())
}
</code></pre>

<ul>
<li>A. 1 1</li>
<li>B. 0 1</li>
<li>C. 1 0</li>
<li>D. 0 0</li>
</ul>

<p>参考答案及解析：B。知识点：defer、返回值。注意一下，increaseA() 的返回参数是匿名，increaseB() 是具名。关于 defer 与返回值的知识点，后面我会写篇文章详细分析，到时候可以看下文章的讲解。</p>

<p>3.下面代码输出什么？</p>

<pre><code class="language-go">type A interface {
	ShowA() int
}

type B interface {
	ShowB() int
}

type Work struct {
	i int
}

func (w Work) ShowA() int {
	return w.i + 10
}

func (w Work) ShowB() int {
	return w.i + 20
}

func main() {
	var a A = Work{3}
	s := a.(Work)
	fmt.Println(s.ShowA())
	fmt.Println(s.ShowB())
}
</code></pre>

<ul>
<li>A. 13 23</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：A。知识点：类型断言。这道题可以和第 15 天的第三题 和第 16 天的第三题结合起来看。</p>

<h3 id="第-18-天">第 18 天</h3>

<p>1.f1()、f2()、f3() 函数分别返回什么？</p>

<pre><code class="language-go">func f1() (r int) {
	defer func() {
		r++
	}()
	return 0
}


func f2() (r int) {
	t := 5
	defer func() {
		t = t + 5
	}()
	return t
}


func f3() (r int) {
	defer func(r int) {
		r = r + 5
	}(r)
	return 1
}
</code></pre>

<p>参考答案及解析：1 5 1。知识点：defer、返回值。</p>

<h3 id="第-19-天">第 19 天</h3>

<p>1.下面代码段输出什么？</p>

<pre><code class="language-go">type Person struct {
	age int
}

func main() {
	person := &amp;Person{28}

	// 1. 
	defer fmt.Println(person.age)

	// 2.
	defer func(p *Person) {
		fmt.Println(p.age)
	}(person)  

	// 3.
	defer func() {
		fmt.Println(person.age)
	}()

	person.age = 29
}
</code></pre>

<p>参考答案及解析：29 29 28。变量 person 是一个指针变量 。</p>

<p>1.person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；</p>

<p>2.defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；</p>

<p>3.很简单，闭包引用，输出 29；</p>

<p>又由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 29 28。</p>

<h3 id="第-20-天">第 20 天</h3>

<p>1.下面这段代码正确的输出是什么？</p>

<pre><code class="language-go">func f() {
	defer fmt.Println(&quot;D&quot;)
	fmt.Println(&quot;F&quot;)
}

func main() {
	f()
	fmt.Println(&quot;M&quot;)
}
</code></pre>

<ul>
<li>A. F M D</li>
<li>B. D F M</li>
<li>C. F D M</li>
</ul>

<p>参考答案及解析：C。被调用函数里的 defer 语句在返回之前就会被执行，所以输出顺序是 F D M。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">type Person struct {
	age int
}

func main() {
	person := &amp;Person{28}

	// 1.
	defer fmt.Println(person.age)

	// 2.
	defer func(p *Person) {
		fmt.Println(p.age)
	}(person)

	// 3.
	defer func() {
		fmt.Println(person.age)
	}()

	person = &amp;Person{29}
}
</code></pre>

<p>参考答案及解析：29 28 28。<br></p>

<p>这道题在第 19 天题目的基础上做了一点点小改动，前一题最后一行代码 <code>person.age = 29</code> 是修改引用对象的成员 age，这题最后一行代码 <code>person = &amp;Person{29}</code> 是修改引用对象本身，来看看有什么区别。</p>

<p>1.person.age 这一行代码跟之前含义是一样的，此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；</p>

<p>2.defer 缓存的是结构体 Person{28} 的地址，这个地址指向的结构体没有被改变，最后 defer 语句后面的函数执行的时候取出仍是 28；</p>

<p>3.闭包引用，person 的值已经被改变，指向结构体 <code>Person{29}</code>，所以输出 29.</p>

<p>由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 28 28。</p>

<h3 id="第-21-天">第 21 天</h3>

<p>1.下面的两个切片声明中有什么区别？哪个更可取？</p>

<pre><code class="language-go">A. var a []int
B. a := []int{}
</code></pre>

<p>参考答案及解析：第一种切片声明不会分配内存，优先选择。</p>

<ol>
<li>A、B、C、D 哪些选项有语法错误？
```go
type S struct {
}</li>
</ol>

<p>func f(x interface{}) {
}</p>

<p>func g(x *interface{}) {
}</p>

<p>func main() {
	s := S{}
	p := &amp;s
	f(s) //A
	g(s) //B
	f(p) //C
	g(p) //D
}</p>

<pre><code>参考答案及解析：BD。函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。

&gt;永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。


3.下面 A、B 两处应该填入什么代码，才能确保顺利打印出结果？
```go
type S struct {
	m string
}

func f() *S {
	return __  //A
}

func main() {
	p := __    //B
	fmt.Println(p.m) //print &quot;foo&quot;
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code>A. &amp;S{&quot;foo&quot;} 
B. *f() 或者 f()
</code></pre>

<p>f() 函数返回参数是指针类型，所以可以用 &amp; 取结构体的指针；B 处，如果填 <code>*f()</code>，则 p 是 S 类型；如果填 <code>f()</code>，则 p 是 *S 类型，不过都可以使用 <code>p.m</code> 取得结构体的成员。</p>

<h3 id="第-22-天">第 22 天</h3>

<p>1.下面的代码有几处语法问题，各是什么？</p>

<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
)
func main() {
    var x string = nil
    if x == nil {
        x = &quot;default&quot;
    }
    fmt.Println(x)
}
</code></pre>

<p>参考答案及解析：2 处有语法问题。golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较。</p>

<p>2.return 之后的 defer 语句会执行吗，下面这段代码输出什么？</p>

<pre><code class="language-go">var a bool = true
func main() {
	defer func(){
		fmt.Println(&quot;1&quot;)
	}()
	if a == true {
		fmt.Println(&quot;2&quot;)
		return
	}
	defer func(){
		fmt.Println(&quot;3&quot;)
	}()
}
</code></pre>

<p>参考答案及解析：2 1。defer 关键字后面的函数或者方法想要执行必须先注册，return 之后的 defer 是不能注册的， 也就不能执行后面的函数或方法。</p>

<p>Reference:<br>
1.<a href="https://studygolang.com/topics/9967">https://studygolang.com/topics/9967</a><br></p>

<h3 id="第-23-天">第 23 天</h3>

<p>1.下面这段代码输出什么？为什么？</p>

<pre><code class="language-go">func main() {

	s1 := []int{1, 2, 3}
	s2 := s1[1:]
	s2[1] = 4
	fmt.Println(s1)
	s2 = append(s2, 5, 6, 7)
	fmt.Println(s1)
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">[1 2 4]
[1 2 4]
</code></pre>

<p>我们已经知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] = 4 语句影响 s1。</p>

<p>而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。</p>

<p>但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。</p>

<p>2.下面选项正确的是？</p>

<pre><code class="language-go">func main() {
	if a := 1; false {
	} else if b := 2; false {
	} else {
		println(a, b)
	}
}
</code></pre>

<ul>
<li>A. 1 2</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：A。</p>

<p>推荐一篇文章，讲的很详细 <a href="https://tonybai.com/2018/05/11/the-analysis-of-a-go-code-snippet-about-code-blocks-and-scope/">https://tonybai.com/2018/05/11/the-analysis-of-a-go-code-snippet-about-code-blocks-and-scope/</a></p>

<h3 id="第-24-天">第 24 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	m := map[int]string{0:&quot;zero&quot;,1:&quot;one&quot;}
	for k,v := range m {
		fmt.Println(k,v)
	}
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">0 zero
1 one
// 或者
1 one
0 zero
</code></pre>

<p>map 的输出是无序的。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	a := 1
	b := 2
	defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))
	a = 0
	defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))
	b = 1
}

func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
</code></pre>

<p>程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数，即：<code>calc(&quot;10&quot;,a,b)</code>，输出：10 1 2 3，得到值 3，因为
defer 定义的函数是延迟函数，故 calc(&ldquo;1&rdquo;,1,3) 会被延迟执行；</p>

<p>程序执行到第五行的时候，同样先执行 calc(&ldquo;20&rdquo;,a,b) 输出：20 0 2 2 得到值 2，同样将 calc(&ldquo;2&rdquo;,0,2) 延迟执行；</p>

<p>程序执行到末尾的时候，按照栈先进后出的方式依次执行：calc(&ldquo;2&rdquo;,0,2)，calc(&ldquo;1&rdquo;,1,3)，则就依次输出：2 0 2 2，1 1 3 4。</p>

<h3 id="第-25-天">第 25 天</h3>

<p>1.下面这段代码输出什么？为什么？</p>

<pre><code class="language-go">func (i int) PrintInt ()  {
	fmt.Println(i)
}

func main() {
	var i int = 1
	i.PrintInt()
}
</code></pre>

<ul>
<li>A. 1</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：B。<strong>基于类型创建的方法必须定义在同一个包内</strong>，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。解决的办法可以定义一种新的类型：</p>

<pre><code class="language-go">type Myint int

func (i Myint) PrintInt ()  {
	fmt.Println(i)
}

func main() {
	var i Myint = 1
	i.PrintInt()
}
</code></pre>

<p>2.下面这段代码输出什么？为什么？</p>

<pre><code class="language-go">type People interface {
	Speak(string) string
}

type Student struct{}

func (stu *Student) Speak(think string) (talk string) {
	if think == &quot;speak&quot; {
		talk = &quot;speak&quot;
	} else {
		talk = &quot;hi&quot;
	}
	return
}

func main() {
	var peo People = Student{}
	think := &quot;speak&quot;
	fmt.Println(peo.Speak(think))
}
</code></pre>

<ul>
<li>A. speak</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：B。编译错误 <code>Student does not implement People (Speak method has pointer receiver)</code>，值类型 <code>Student</code> 没有实现接口的 <code>Speak()</code> 方法，而是指针类型 <code>*Student</code> 实现改方法。</p>

<p>详细请参考这篇文章 <a href="https://seekload.net/2019/06/06/go-study-method.html">https://seekload.net/2019/06/06/go-study-method.html</a></p>

<h3 id="第-26-天">第 26 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">const (
	a = iota
	b = iota
)
const (
	name = &quot;name&quot;
	c    = iota
	d    = iota
)
func main() {
	fmt.Println(a)
	fmt.Println(b)
	fmt.Println(c)
	fmt.Println(d)
}
</code></pre>

<p>参考答案及解析：0 1 1 2。知识点：iota 的用法。</p>

<p>iota 是 golang 语言的常量计数器，只能在常量的表达式中使用。</p>

<p>iota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。</p>

<p>Reference:<br>
1.<a href="https://studygolang.com/articles/2192">https://studygolang.com/articles/2192</a><br></p>

<p>2.下面这段代码输出什么？为什么？</p>

<pre><code class="language-go">type People interface {
	Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func main() {

	var s *Student
	if s == nil {
		fmt.Println(&quot;s is nil&quot;)
	} else {
		fmt.Println(&quot;s is not nil&quot;)
	}
	var p People = s
	if p == nil {
		fmt.Println(&quot;p is nil&quot;)
	} else {
		fmt.Println(&quot;p is not nil&quot;)
	}
}
</code></pre>

<p>参考答案及解析：<code>s is nil</code> 和 <code>p is not nil</code>。这道题会不会有点诧异，我们分配给变量 p 的值明明是 nil，然而 p 却不是 nil。记住一点，<strong>当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil</strong>。上面的代码，给变量 p 赋值之后，p 的动态值是 nil，但是动态类型却是 *Student，是一个 nil 指针，所以相等条件不成立。</p>

<h3 id="第-27-天">第 27 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">type Direction int

const (
	North Direction = iota
	East
	South
	West
)

func (d Direction) String() string {
	return [...]string{&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;}[d]
}

func main() {
	fmt.Println(South)
}
</code></pre>

<p>参考答案及解析：South。知识点：iota 的用法、类型的 <code>String()</code> 方法。</p>

<p>根据 iota 的用法推断出 South 的值是 2；另外，如果类型定义了 <code>String()</code> 方法，当使用 <code>fmt.Printf()</code>、<code>fmt.Print()</code> 和 <code>fmt.Println()</code> 会自动使用 String() 方法，实现字符串的打印。</p>

<p>Reference:<br>
1.<a href="https://wiki.jikexueyuan.com/project/the-way-to-go/10.7.html">https://wiki.jikexueyuan.com/project/the-way-to-go/10.7.html</a><br>
2.<a href="https://www.sunansheng.com/archives/24.html">https://www.sunansheng.com/archives/24.html</a><br>3.<a href="https://yourbasic.org/golang/iota/">https://yourbasic.org/golang/iota/</a><br></p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">type Math struct {
	x, y int
}

var m = map[string]Math{
	&quot;foo&quot;: Math{2, 3},
}

func main() {
	m[&quot;foo&quot;].x = 4
	fmt.Println(m[&quot;foo&quot;].x)
}
</code></pre>

<ul>
<li>A. 4</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：B，编译报错 <code>cannot assign to struct field m[&quot;foo&quot;].x in map</code>。错误原因：对于类似 <code>X = Y</code>的赋值操作，必须知道 <code>X</code> 的地址，才能够将 <code>Y</code> 的值赋给 <code>X</code>，但 go 中的 map 的 value 本身是不可寻址的。</p>

<p>有两个解决办法：</p>

<p>a.使用临时变量</p>

<pre><code class="language-go">type Math struct {
	x, y int
}

var m = map[string]Math{
	&quot;foo&quot;: Math{2, 3},
}

func main() {
	tmp := m[&quot;foo&quot;]
	tmp.x = 4
	m[&quot;foo&quot;] = tmp
	fmt.Println(m[&quot;foo&quot;].x)
}
</code></pre>

<p>b.修改数据结构</p>

<pre><code class="language-go">type Math struct {
	x, y int
}

var m = map[string]*Math{
	&quot;foo&quot;: &amp;Math{2, 3},
}

func main() {
	m[&quot;foo&quot;].x = 4
	fmt.Println(m[&quot;foo&quot;].x)
	fmt.Printf(&quot;%#v&quot;, m[&quot;foo&quot;])   // %#v 格式化输出详细信息
}
</code></pre>

<p>references:
&gt;0.<a href="https://blog.csdn.net/qq_36431213/article/details/82805043">https://blog.csdn.net/qq_36431213/article/details/82805043</a><br>
1.<a href="https://www.cnblogs.com/DillGao/p/7930674.html">https://www.cnblogs.com/DillGao/p/7930674.html</a><br>
2.<a href="https://haobook.readthedocs.io/zh_CN/latest/periodical/201611/zhangan.html">https://haobook.readthedocs.io/zh_CN/latest/periodical/201611/zhangan.html</a><br>
3.<a href="https://suraj.pro/post/golang_workaround/">https://suraj.pro/post/golang_workaround/</a><br>
4.<a href="https://blog.ijun.org/2017/07/cannot-assign-to-struct-field-in-map.html">https://blog.ijun.org/2017/07/cannot-assign-to-struct-field-in-map.html</a><br></p>

<h3 id="第-28-天">第 28 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-go">func main() {
	fmt.Println([...]int{1} == [2]int{1})
	fmt.Println([]int{1} == []int{1})
}
</code></pre>

<p>参考答案及解析：有两处错误
- go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 <code>[...]int{1}</code> 和 <code>[2]int{1}</code> 是两种不同的类型，不能比较；<br>
- 切片是不能比较的；</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">var p *int

func foo() (*int, error) {
	var i int = 5
	return &amp;i, nil
}

func bar() {
	//use p
	fmt.Println(*p)
}

func main() {
	p, err := foo()
	if err != nil {
		fmt.Println(err)
		return
	}
	bar()
	fmt.Println(*p)
}
</code></pre>

<ul>
<li>A. 5 5</li>
<li>B. runtime error</li>
</ul>

<p>参考答案及解析：B。知识点：变量作用域。问题出在操作符<code>:=</code>，对于使用<code>:=</code>定义的变量，如果新变量与同名已定义的变量不在同一个作用域中，那么 Go 会新定义这个变量。对于本例来说，main() 函数里的 p 是新定义的变量，会遮住全局变量 p，导致执行到<code>bar()</code>时程序，全局变量 p 依然还是 nil，程序随即 Crash。</p>

<p>正确的做法是将 main() 函数修改为：</p>

<pre><code class="language-go">func main() {
	var err error
	p, err = foo()
	if err != nil {
		fmt.Println(err)
		return
	}
	bar()
	fmt.Println(*p)
}
</code></pre>

<p>这道题目引自 Tony Bai 老师的一篇文章，原文讲的很详细，推荐。
<a href="https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/">https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/</a></p>

<h3 id="第-29-天">第 29 天</h3>

<p>1.下面这段代码能否正常结束？</p>

<pre><code class="language-go">func main() {
	v := []int{1, 2, 3}
	for i := range v {
		v = append(v, i)
	}
}
</code></pre>

<p>参考答案及解析：不会出现死循环，能正常结束。</p>

<p>循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数。</p>

<p>2.下面这段代码输出什么？为什么？</p>

<pre><code class="language-go">func main() {

	var m = [...]int{1, 2, 3}

	for i, v := range m {
		go func() {
			fmt.Println(i, v)
		}()
	}

	time.Sleep(time.Second * 3)
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">2 3
2 3
2 3
</code></pre>

<p>for range 使用短变量声明 (:=) 的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。</p>

<p>各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个 goroutine 启动时的 i, v值。可以理解为闭包引用，使用的是上下文环境的值。两种可行的 fix 方法:</p>

<p>a.使用函数传递</p>

<pre><code class="language-go">for i, v := range m {
	go func(i,v int) {
		fmt.Println(i, v)
	}(i,v)
}
</code></pre>

<p>b.使用临时变量保留当前值</p>

<pre><code class="language-go">for i, v := range m {
	i := i           // 这里的 := 会重新声明变量，而不是重用
	v := v
	go func() {
		fmt.Println(i, v)
	}()
}
</code></pre>

<p>reference:<br>
1.<a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>

<h3 id="第-30-天">第 30 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">func f(n int) (r int) {
	defer func() {
		r += n
		recover()
	}()

	var f func()

	defer f()
	f = func() {
		r += 2
	}
	return n + 1
}

func main() {
	fmt.Println(f(3))
}
</code></pre>

<p>参考答案及解析：7。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	var a = [5]int{1, 2, 3, 4, 5}
	var r [5]int

	for i, v := range a {
		if i == 0 {
			a[1] = 12
			a[2] = 13
		}
		r[i] = v
	}
	fmt.Println(&quot;r = &quot;, r)
	fmt.Println(&quot;a = &quot;, a)
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">r =  [1 2 3 4 5]
a =  [1 12 13 4 5]
</code></pre>

<p>range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。就这个例子来说，假设 b 是 a 的副本，则 range 循环代码是这样的：</p>

<pre><code class="language-go">for i, v := range b {
	if i == 0 {
		a[1] = 12
		a[2] = 13
	}
	r[i] = v
}
</code></pre>

<p>因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。</p>

<p>如果想要 r 和 a 一样输出，修复办法：</p>

<pre><code class="language-go">func main() {
	var a = [5]int{1, 2, 3, 4, 5}
	var r [5]int

	for i, v := range &amp;a {
		if i == 0 {
			a[1] = 12
			a[2] = 13
		}
		r[i] = v
	}
	fmt.Println(&quot;r = &quot;, r)
	fmt.Println(&quot;a = &quot;, a)
}
</code></pre>

<p>输出：</p>

<pre><code class="language-go">r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
</code></pre>

<p>修复代码中，使用 *[5]int 作为 range 表达式，其副本依旧是一个指向原数组 a 的指针，因此后续所有循环中均是 &amp;a 指向的原数组亲自参与的，因此 v 能从 &amp;a 指向的原数组中取出 a 修改后的值。</p>

<p>reference:
<a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>

<h3 id="第-31-天">第 31 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">func change(s ...int) {
	s = append(s,3)
}

func main() {
	slice := make([]int,5,5)
	slice[0] = 1
	slice[1] = 2
	change(slice...)
	fmt.Println(slice)
	change(slice[0:2]...)
	fmt.Println(slice)
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">[1 2 0 0 0]
[1 2 3 0 0]
</code></pre>

<p>知识点：可变函数、append()操作。Go 提供的语法糖<code>...</code>，可以将 slice 传进可变函数，不会创建新的切片。第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变； 第二次调用change() 函数时，使用了操作符<code>[i,j]</code>获得一个新的切片，假定为 slice1，
它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	var a = []int{1, 2, 3, 4, 5}
	var r [5]int

	for i, v := range a {
		if i == 0 {
			a[1] = 12
			a[2] = 13
		}
		r[i] = v
	}
	fmt.Println(&quot;r = &quot;, r)
	fmt.Println(&quot;a = &quot;, a)
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
</code></pre>

<p>这道题是昨天第二题的一个解决办法，这的 a 是一个切片，那切片是怎么实现的呢？切片在 go 的内部结构有一个指向底层数组的指针，当 range 表达式发生复制时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，所以通过 v 可以获得修改后的数组元素。</p>

<p>引自：
<a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>

<h3 id="第-32-天">第 32 天</h3>

<p>1.下面这段代码输出结果正确吗？</p>

<pre><code class="language-go">type Foo struct {
	bar string
}
func main() {
	s1 := []Foo{
		{&quot;A&quot;},
		{&quot;B&quot;},
		{&quot;C&quot;},
	}
	s2 := make([]*Foo, len(s1))
	for i, value := range s1 {
		s2[i] = &amp;value
	}
	fmt.Println(s1[0], s1[1], s1[2])
	fmt.Println(s2[0], s2[1], s2[2])
}
</code></pre>

<pre><code class="language-go">输出：
{A} {B} {C}
&amp;{A} &amp;{B} &amp;{C}
</code></pre>

<p>参考答案及解析：s2 的输出结果错误。s2 的输出是 <code>&amp;{C} &amp;{C} &amp;{C}</code>，在 29 天我们提到过，for range 使用短变量声明(:=)的形式迭代变量时，变量 i、value 在每次循环体中都会被重用，而不是重新声明。所以 s2 每次填充的都是临时变量 value 的地址，而在最后一次循环中，value 被赋值为{c}。因此，s2 输出的时候显示出了三个 &amp;{c}。</p>

<p>可行的解决办法如下：</p>

<pre><code class="language-go">for i := range s1 {
	s2[i] = &amp;s1[i]
}
</code></pre>

<p>2.下面代码里的 counter 的输出值？</p>

<pre><code class="language-go">func main() {

	var m = map[string]int{
		&quot;A&quot;: 21,
		&quot;B&quot;: 22,
		&quot;C&quot;: 23,
	}
	counter := 0
	for k, v := range m {
		if counter == 0 {
			delete(m, &quot;A&quot;)
		}
		counter++
		fmt.Println(k, v)
	}
	fmt.Println(&quot;counter is &quot;, counter)
}
</code></pre>

<ul>
<li>A. 2</li>
<li>B. 3</li>
<li>C. 2 或 3</li>
</ul>

<p>参考答案及解析：C。for range map 是无序的，如果第一次循环到 A，则输出 3；否则输出 2。</p>

<h3 id="第-33-天">第 33 天</h3>

<p>1.关于协程，下面说法正确是（）</p>

<ul>
<li>A. 协程和线程都可以实现程序的并发执行；</li>
<li>B. 线程比协程更轻量级；</li>
<li>C. 协程不存在死锁问题；</li>
<li>D. 通过 channel 来进行协程间的通信；</li>
</ul>

<p>参考答案及解析：AD。</p>

<p>2.关于循环语句，下面说法正确的有（）</p>

<ul>
<li>A. 循环语句既支持 for 关键字，也支持 while 和 do-while；</li>
<li>B. 关键字 for 的基本使用方法与 C/C++ 中没有任何差异；</li>
<li>C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；</li>
<li>D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；</li>
</ul>

<p>参考答案及解析：CD。</p>

<p>3.下面代码输出正确的是？</p>

<pre><code class="language-go">func main() {
	i := 1
	s := []string{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}
	i, s[i-1] = 2, &quot;Z&quot;
	fmt.Printf(&quot;s: %v \n&quot;, s)
}
</code></pre>

<ul>
<li>A. s: [Z,B,C]</li>
<li>B. s: [A,Z,C]</li>
</ul>

<p>参考答案及解析：A。知识点：多重赋值。</p>

<p>多重赋值分为两个步骤，有先后顺序：<br></p>

<ul>
<li>计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；</li>
<li>赋值；</li>
</ul>

<p>所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 <code>i, s[0] = 2, &quot;Z&quot;</code>。</p>

<h3 id="第-34-天">第 34 天</h3>

<p>1.关于类型转化，下面选项正确的是？</p>

<pre><code class="language-go">A.
type MyInt int
var i int = 1
var j MyInt = i

B.
type MyInt int
var i int = 1
var j MyInt = (MyInt)i

C.
type MyInt int
var i int = 1
var j MyInt = MyInt(i)

D.
type MyInt int
var i int = 1
var j MyInt = i.(MyInt)
</code></pre>

<p>参考答案及解析：C。知识点：强制类型转化。</p>

<p>2.关于switch语句，下面说法正确的有?</p>

<ul>
<li>A. 条件表达式必须为常量或者整数；</li>
<li>B. 单个case中，可以出现多个结果选项；</li>
<li>C. 需要用break来明确退出一个case；</li>
<li>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；</li>
</ul>

<p>参考答案及解析：BD。</p>

<p>3.如果 Add() 函数的调用代码为：</p>

<pre><code class="language-go">func main() {
	var a Integer = 1
	var b Integer = 2
	var i interface{} = &amp;a
	sum := i.(*Integer).Add(b)
	fmt.Println(sum)
}
</code></pre>

<p>则Add函数定义正确的是()</p>

<pre><code class="language-go">A.
type Integer int
func (a Integer) Add(b Integer) Integer {
        return a + b
}

B.
type Integer int
func (a Integer) Add(b *Integer) Integer {
        return a + *b
}

C.
type Integer int
func (a *Integer) Add(b Integer) Integer {
        return *a + b
}

D.
type Integer int
func (a *Integer) Add(b *Integer) Integer {
        return *a + *b
}
</code></pre>

<p>参考答案及解析：AC。知识点：类型断言、方法集。</p>

<h3 id="第-35-天">第 35 天</h3>

<p>1.关于 bool 变量 b 的赋值，下面错误的用法是？</p>

<ul>
<li>A. b = true</li>
<li>B. b = 1</li>
<li>C. b = bool(1)</li>
<li>D. b = (1 == 2)</li>
</ul>

<p>参考答案及解析：BC。</p>

<p>2.关于变量的自增和自减操作，下面语句正确的是？</p>

<pre><code class="language-go">A.
i := 1
i++

B.
i := 1
j = i++

C.
i := 1
++i

D.
i := 1
i--
</code></pre>

<p>参考答案及解析：AD。知识点：自增自减操作。i++ 和 i&ndash; 在 Go 语言中是语句，不是表达式，因此不能赋值给另外的变量。此外没有 ++i 和 &ndash;i。</p>

<p>3.关于GetPodAction定义，下面赋值正确的是</p>

<pre><code class="language-go">type Fragment interface {
        Exec(transInfo *TransInfo) error
}
type GetPodAction struct {
}
func (g GetPodAction) Exec(transInfo *TransInfo) error {
        ...
        return nil
}
</code></pre>

<ul>
<li>A. var fragment Fragment = new(GetPodAction)</li>
<li>B. var fragment Fragment = GetPodAction</li>
<li>C. var fragment Fragment = &amp;GetPodAction{}</li>
<li>D. var fragment Fragment = GetPodAction{}</li>
</ul>

<p>参考答案及解析：ACD。</p>

<h3 id="第-36-天">第 36 天</h3>

<p>1.关于函数声明，下面语法正确的是？</p>

<ul>
<li>A. func f(a, b int) (value int, err error)</li>
<li>B. func f(a int, b int) (value int, err error)</li>
<li>C. func f(a, b int) (value int, error)</li>
<li>D. func f(a int, b int) (int, int, error)</li>
</ul>

<p>参考答案及解析：ABD。</p>

<p>2.关于整型切片的初始化，下面正确的是？</p>

<ul>
<li>A. s := make([]int)</li>
<li>B. s := make([]int, 0)</li>
<li>C. s := make([]int, 5, 10)</li>
<li>D. s := []int{1, 2, 3, 4, 5}</li>
</ul>

<p>参考答案及解析：BCD。</p>

<p>3.下面代码会触发异常吗？请说明。</p>

<pre><code class="language-go">func main() {
	runtime.GOMAXPROCS(1)
	int_chan := make(chan int, 1)
	string_chan := make(chan string, 1)
	int_chan &lt;- 1
	string_chan &lt;- &quot;hello&quot;
	select {
	case value := &lt;-int_chan:
		fmt.Println(value)
	case value := &lt;-string_chan:
		panic(value)
	}
}
</code></pre>

<p>参考答案及解析：<code>select</code> 会随机选择一个可用通道做收发操作，所以可能触发异常，也可能不会。</p>

<h3 id="第-37-天">第 37 天</h3>

<p>1.关于channel的特性，下面说法正确的是</p>

<ul>
<li>A. 给一个 nil channel 发送数据，造成永远阻塞</li>
<li>B. 从一个 nil channel 接收数据，造成永远阻塞</li>
<li>C. 给一个已经关闭的 channel 发送数据，引起 panic</li>
<li>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</li>
</ul>

<p>参考答案及解析：ABCD。</p>

<p>2.下面代码有什么问题？</p>

<pre><code class="language-go">const i = 100
var j = 123

func main() {
	fmt.Println(&amp;j, j)
	fmt.Println(&amp;i, i)
}
</code></pre>

<p>参考答案及解析：编译报错<code>cannot take the address of i</code>。知识点：常量。常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。</p>

<p>3.下面代码能否编译通过？如果通过，输出什么？</p>

<pre><code class="language-go">func GetValue(m map[int]string, id int) (string, bool) {

	if _, exist := m[id]; exist {
		return &quot;exist&quot;, true
	}
	return nil, false
}
func main() {
	intmap := map[int]string{
		1: &quot;a&quot;,
		2: &quot;b&quot;,
		3: &quot;c&quot;,
	}

	v, err := GetValue(intmap, 3)
	fmt.Println(v, err)
}
</code></pre>

<p>参考答案及解析：不能通过编译。知识点：函数返回值类型。nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错:<code>cannot use nil as type string in return argument</code>.</p>

<h3 id="第-38-天">第 38 天</h3>

<p>1.关于异常的触发，下面说法正确的是？</p>

<ul>
<li>A. 空指针解析；</li>
<li>B. 下标越界；</li>
<li>C. 除数为0；</li>
<li>D. 调用panic函数；</li>
</ul>

<p>参考答案及解析：ABCD。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	x := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
	for v := range x {
		fmt.Print(v)
	}
}
</code></pre>

<p>参考答案及解析：012。注意区别下面代码段：</p>

<pre><code class="language-go">func main() {
	x := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
	for _, v := range x {
		fmt.Print(v)     //输出 abc
	}
}
</code></pre>

<p>3.下面这段代码能否编译通过？如果通过，输出什么？</p>

<pre><code class="language-go">type User struct{}
type User1 User
type User2 = User

func (i User1) m1() {
	fmt.Println(&quot;m1&quot;)
}
func (i User) m2() {
	fmt.Println(&quot;m2&quot;)
}

func main() {
	var i1 User1
	var i2 User2
	i1.m1()
	i2.m2()
}
</code></pre>

<p>参考答案及解析：能，输出<code>m1 m2</code>，第 2 行代码基于类型 User 创建了新类型 User1，第 3 行代码是创建了 User 的类型别名 User2，注意使用 = 定义类型别名。因为 User2 是别名，完全等价于 User，所以 User2 具有 User 所有的方法。但是 i1.m2() 是不能执行的，因为 User1 没有定义该方法。</p>

<h3 id="第-39-天">第 39 天</h3>

<p>1.关于无缓冲和有冲突的channel，下面说法正确的是？</p>

<ul>
<li>A. 无缓冲的channel是默认的缓冲为1的channel；</li>
<li>B. 无缓冲的channel和有缓冲的channel都是同步的；</li>
<li>C. 无缓冲的channel和有缓冲的channel都是非同步的；</li>
<li>D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的；</li>
</ul>

<p>参考答案及解析：D。</p>

<p>2.下面代码是否能编译通过？如果通过，输出什么？</p>

<pre><code class="language-go">func Foo(x interface{}) {
	if x == nil {
		fmt.Println(&quot;empty interface&quot;)
		return
	}
	fmt.Println(&quot;non-empty interface&quot;)
}
func main() {
	var x *int = nil
	Foo(x)
}
</code></pre>

<p>参考答案及解析：<code>non-empty interface</code> 考点：interface 的内部结构，我们知道接口除了有静态类型，还有动态类型和动态值，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。这里的 x 的动态类型是 <code>*int</code>，所以 x 不为 nil。</p>

<p>3.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	ch := make(chan int, 100)
	// A
	go func() {              
		for i := 0; i &lt; 10; i++ {
			ch &lt;- i
		}
	}()
	// B
	go func() {
		for {
			a, ok := &lt;-ch
			if !ok {
				fmt.Println(&quot;close&quot;)
				return
			}
			fmt.Println(&quot;a: &quot;, a)
		}
	}()
	close(ch)
	fmt.Println(&quot;ok&quot;)
	time.Sleep(time.Second * 10)
}
</code></pre>

<p>参考答案及解析：程序抛异常。先定义下，第一个协程为 A 协程，第二个协程为 B 协程；当 A 协程还没起时，主协程已经将 channel 关闭了，当 A 协程往关闭的 channel 发送数据时会 panic，<code>panic: send on closed channel</code>。</p>

<h3 id="第-40-天">第 40 天</h3>

<p>1.关于select机制，下面说法正确的是?</p>

<ul>
<li>A. select机制用来处理异步IO问题；</li>
<li>B. select机制最大的一条限制就是每个case语句里必须是一个IO操作；</li>
<li>C. golang在语言级别支持select关键字；</li>
<li>D. select关键字的用法与switch语句非常类似，后面要带判断条件；</li>
</ul>

<p>参考答案及解析：ABC。</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">func Stop(stop &lt;-chan bool) {
	close(stop)
}
</code></pre>

<p>参考答案及解析：有方向的 channel 不可被关闭。</p>

<p>3.下面这段代码存在什么问题？</p>

<pre><code class="language-go">type Param map[string]interface{}

type Show struct {
	*Param
}

func main() {
	s := new(Show)
	s.Param[&quot;day&quot;] = 2
}
</code></pre>

<p>参考答案及解析：存在两个问题：1.map 需要初始化才能使用；2.指针不支持索引。修复代码如下：</p>

<pre><code class="language-go">func main() {
	s := new(Show)
	// 修复代码
	p := make(Param)
	p[&quot;day&quot;] = 2
	s.Param = &amp;p
	tmp := *s.Param
	fmt.Println(tmp[&quot;day&quot;])
}
</code></pre>

<h3 id="第-41-天">第 41 天</h3>

<p>1.下面代码编译能通过吗？</p>

<pre><code class="language-go">func main()  
{ 
    fmt.Println(&quot;hello world&quot;)
}
</code></pre>

<p>参考答案及解析：编译错误。</p>

<pre><code class="language-go">syntax error: unexpected semicolon or newline before {
</code></pre>

<p>Go 语言中，大括号不能放在单独的一行。</p>

<p>正确的代码如下：</p>

<pre><code class="language-go">func main() {
	fmt.Println(&quot;works&quot;)
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">var x = []int{2: 2, 3, 0: 1}

func main() {
	fmt.Println(x)
}
</code></pre>

<p>参考答案及解析：输出<code>[1 0 2 3]</code>，字面量初始化切片时候，可以指定索引，没有指定索引的元素会在前一个索引基础之上加一，所以输出<code>[1 0 2 3]</code>，而不是<code>[1 3 2]</code>。</p>

<p>3.下面这段代码输出什么？</p>

<pre><code class="language-go">func incr(p *int) int {
	*p++
	return *p
}
func main() {
	v := 1
	incr(&amp;v)
	fmt.Println(v)
}
</code></pre>

<p>参考答案及解析：2。知识点：指针。p 是指针变量，指向变量 v，<code>*p++</code>操作的意思是取出变量 v 的值并执行加一操作，所以 v 的最终值是 2。</p>

<h3 id="第-42-天">第 42 天</h3>

<p>1.请指出下面代码的错误？</p>

<pre><code class="language-go">package main

var gvar int 

func main() {  
    var one int   
    two := 2      
    var three int 
    three = 3

    func(unused string) {
        fmt.Println(&quot;Unused arg. No compile error&quot;)
    }(&quot;what?&quot;)
}
</code></pre>

<p>参考答案及解析：变量 one、two 和 three 声明未使用。知识点：未使用变量。如果有未使用的变量代码将编译失败。但也有例外，函数中声明的变量必须要使用，但可以有未使用的全局变量。函数的参数未使用也是可以的。</p>

<p>如果你给未使用的变量分配了一个新值，代码也还是会编译失败。你需要在某个地方使用这个变量，才能让编译器愉快的编译。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	var one int
	_ = one

	two := 2
	fmt.Println(two)

	var three int
	three = 3
	one = three

	var four int
	four = four
}
</code></pre>

<p>另一个选择是注释掉或者移除未使用的变量 。</p>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">type ConfigOne struct {
	Daemon string
}

func (c *ConfigOne) String() string {
	return fmt.Sprintf(&quot;print: %v&quot;, c)
}

func main() {
	c := &amp;ConfigOne{}
	c.String()
}
</code></pre>

<p>参考答案及解析：运行时错误。如果类型实现 String() 方法，当格式化输出时会自动使用 String() 方法。上面这段代码是在该类型的 String() 方法内使用格式化输出，导致递归调用，最后抛错。</p>

<pre><code class="language-go">runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow
</code></pre>

<p>3.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	var a = []int{1, 2, 3, 4, 5}
	var r = make([]int, 0)

	for i, v := range a {
		if i == 0 {
			a = append(a, 6, 7)
		}

		r = append(r, v)
	}

	fmt.Println(r)
}
</code></pre>

<p>参考答案及解析：<code>[1 2 3 4 5]</code>。a 在 for range 过程中增加了两个元素
，len 由 5 增加到 7，但 for range 时会使用 a 的副本 a&rsquo; 参与循环，副本的 len 依旧是 5，因此 for range 只会循环 5 次，也就只获取 a 对应的底层数组的前 5 个元素。</p>

<h3 id="第-43-天">第 43 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-go">import (  
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;time&quot;
)
func main() {  
}
</code></pre>

<p>参考答案及解析：导入的包没有被使用。如果引入一个包，但是未使用其中如何函数、接口、结构体或变量的话，代码将编译失败。</p>

<p>如果你真的需要引入包，可以使用下划线操作符，<code>_</code>，来作为这个包的名字，从而避免失败。下划线操作符用于引入，但不使用。</p>

<p>我们还可以注释或者移除未使用的包。</p>

<p>修复代码：</p>

<pre><code class="language-go">import (  
    _ &quot;fmt&quot;
    &quot;log&quot;
    &quot;time&quot;
)
var _ = log.Println
func main() {  
    _ = time.Now
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
    x := interface{}(nil)
    y := (*int)(nil)
    a := y == x
    b := y == nil
    _, c := x.(interface{})
    println(a, b, c)
}
</code></pre>

<ul>
<li>A. true true false</li>
<li>B. false true true</li>
<li>C. true true true</li>
<li>D. false true false</li>
</ul>

<p>参考答案及解析：D。知识点：类型断言。类型断言语法：i.(Type)，其中 i 是接口，Type 是类型或接口。编译时会自动检测 i 的动态类型与 Type 是否一致。但是，如果动态类型不存在，则断言总是失败。参考文章《接口2》</p>

<p>3.下面代码有几处错误的地方？请说明原因。</p>

<pre><code class="language-go">func main() {
    
	var s []int
    s = append(s,1)
    
    var m map[string]int
    m[&quot;one&quot;] = 1 
}
</code></pre>

<p>参考答案及解析：有 1 出错误，不能对 nil 的 map 直接赋值，需要使用 make() 初始化。但可以使用 append() 函数对为 nil 的 slice 增加元素。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	var m map[string]int
	m = make(map[string]int)
	m[&quot;one&quot;] = 1
}
</code></pre>

<h3 id="第-44-天">第 44 天</h3>

<p>1.下面代码有什么问题？</p>

<pre><code class="language-go">func main() {
	m := make(map[string]int,2)
	cap(m) 
}
</code></pre>

<p>参考答案及解析：问题：使用 cap() 获取 map 的容量。1.使用 make 创建 map 变量时可以指定第二个参数，不过会被忽略。2.cap() 函数适用于数组、数组指针、slice 和 channel，不适用于 map，可以使用 len() 返回 map 的元素个数。</p>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html</a></p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">func main() {  
    var x = nil 
    _ = x
}
</code></pre>

<p>参考答案及解析：nil 用于表示 interface、函数、maps、slices 和 channels 的“零值”。如果不指定变量的类型，编译器猜不出变量的具体类型，导致编译错误。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	var x interface{} = nil
	_ = x
}
</code></pre>

<p>3.下面代码能编译通过吗？</p>

<pre><code class="language-go">type info struct {
	result int
}

func work() (int,error) {
	return 13,nil
}

func main() {
	var data info

	data.result, err := work() 
	fmt.Printf(&quot;info: %+v\n&quot;,data)
}
</code></pre>

<p>参考答案及解析：编译失败。</p>

<pre><code class="language-go">non-name data.result on left side of :=
</code></pre>

<p>不能使用短变量声明设置结构体字段值，修复代码：</p>

<pre><code class="language-go">func main() {
	var data info

	var err error
	data.result, err = work() //ok
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(data)	
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html</a></p>

<h3 id="第-45-天">第 45 天</h3>

<p>1.下面代码有什么错误？</p>

<pre><code class="language-go">func main() {
	one := 0
	one := 1 
}
</code></pre>

<p>参考答案及解析：变量重复声明。不能在单独的声明中重复声明一个变量，但在多变量声明的时候是可以的，但必须保证至少有一个变量是新声明的。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {  
    one := 0
    one, two := 1,2
    one,two = two,one
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></p>

<p>2.下面代码有什么问题？</p>

<pre><code class="language-go">func main() {
	x := []int{
		1,
		2
	}
	_ = x
}
</code></pre>

<p>参考答案及解析：编译错误，第四行代码没有逗号。用字面量初始化数组、slice 和 map 时，最好是在每个元素后面加上逗号，即使是声明在一行或者多行都不会出错。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	x := []int{    // 多行
		1,
		2,
	}
	x = x

	y := []int{3,4,} // 一行 no error
	y = y
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html</a></p>

<p>3.下面代码输出什么？</p>

<pre><code class="language-go">func test(x byte)  {
	fmt.Println(x)
}

func main() {
	var a byte = 0x11 
	var b uint8 = a
	var c uint8 = a + b
	test(c)
}
</code></pre>

<p>参考答案及解析：34。与 rune 是 int32 的别名一样，byte 是 uint8 的别名，别名类型无序转换，可直接转换。</p>

<h3 id="第-46-天">第 46 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-go">func main() {
	const x = 123
	const y = 1.23
	fmt.Println(x)
}
</code></pre>

<p>参考答案及解析：编译可以通过。知识点：常量。常量是一个简单值的标识符，在程序运行时，不会被修改的量。不像变量，常量未使用是能编译通过的。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">const (
	x uint16 = 120
	y
	s = &quot;abc&quot;
	z
)

func main() {
	fmt.Printf(&quot;%T %v\n&quot;, y, y)
	fmt.Printf(&quot;%T %v\n&quot;, z, z)
}
</code></pre>

<p>参考答案及解析：知识点：常量。</p>

<p>输出：</p>

<pre><code class="language-go">uint16 120
string abc
</code></pre>

<p>常量组中如不指定类型和初始化值，则与上一行非空常量右值相同</p>

<p>3.下面代码有什么问题？</p>

<pre><code class="language-go">func main() {  
    var x string = nil 

    if x == nil { 
        x = &quot;default&quot;
    }
}
</code></pre>

<p>参考答案及解析：将 nil 分配给 string 类型的变量。这是个大多数新手会犯的错误。修复代码：</p>

<pre><code class="language-go">func main() {  
    var x string //defaults to &quot;&quot; (zero value)

    if x == &quot;&quot; {
        x = &quot;default&quot;
    }
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html</a></p>

<h3 id="第-47-天">第 47 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-go">func main() {
	data := []int{1,2,3}
	i := 0
	++i
	fmt.Println(data[i++])
}
</code></pre>

<p>参考答案及解析：对于自增、自减，需要注意：</p>

<ul>
<li>自增、自减不在是运算符，只能作为独立语句，而不是表达式；</li>
<li>不像其他语言，Go 语言中不支持 ++i 和 &ndash;i 操作；</li>
</ul>

<p>表达式通常是求值代码，可作为右值或参数使用。而语句表示完成一个任务，比如 if、for 语句等。表达式可作为语句使用，但语句不能当做表达式。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {  
    data := []int{1,2,3}
    i := 0
    i++
    fmt.Println(data[i])
}
</code></pre>

<p>2.下面代码最后一行输出什么？请说明原因。</p>

<pre><code class="language-go">func main() {
	x := 1
	fmt.Println(x)
	{
		fmt.Println(x)
		i,x := 2,2
		fmt.Println(i,x)
	}
	fmt.Println(x)  // print ?
}
</code></pre>

<p>参考答案及解析：输出<code>1</code>。知识点：变量隐藏。使用变量简短声明符号 := 时，如果符号左边有多个变量，只需要保证至少有一个变量是新声明的，并对已定义的变量尽进行赋值操作。但如果出现作用域之后，就会导致变量隐藏的问题，就像这个例子一样。</p>

<p>这个坑很容易挖，但又很难发现。即使对于经验丰富的 Go 开发者而言，这也是一个非常常见的陷阱。</p>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></p>

<h3 id="第-48-天">第 48 天</h3>

<p>1.下面代码有什么问题？</p>

<pre><code class="language-go">type foo struct {
	bar int
}

func main() {
	var f foo
	f.bar, tmp := 1, 2
}
</code></pre>

<p>参考答案及解析：编译错误：</p>

<pre><code class="language-go">non-name f.bar on left side of :=
</code></pre>

<p>:= 操作符不能用于结构体字段赋值。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">func main() {  
    fmt.Println(~2) 
}
</code></pre>

<p>参考答案及解析：编译错误。</p>

<pre><code class="language-go">invalid character U+007E '~'
</code></pre>

<p>很多语言都是采用 ~ 作为按位取反运算符，Go 里面采用的是 ^ 。按位取反之后返回一个每个 bit 位都取反的数，对于有符号的整数来说，是按照补码进行取反操作的（快速计算方法：对数 a 取反，结果为 -(a+1) ），对于无符号整数来说就是按位取反。例如：</p>

<pre><code class="language-go">func main() {
	var a int8 = 3
	var b uint8 = 3
	var c int8 = -3

	fmt.Printf(&quot;^%b=%b %d\n&quot;, a, ^a, ^a) // ^11=-100 -4
	fmt.Printf(&quot;^%b=%b %d\n&quot;, b, ^b, ^b) // ^11=11111100 252
	fmt.Printf(&quot;^%b=%b %d\n&quot;, c, ^c, ^c) // ^-11=10 2
}
</code></pre>

<p>另外需要注意的是，如果作为二元运算符，^ 表示按位异或，即：对应位相同为 0，相异为 1。例如：</p>

<pre><code class="language-go">func main() {
	var a int8 = 3
	var c int8 = 5

	fmt.Printf(&quot;a: %08b\n&quot;,a)
	fmt.Printf(&quot;c: %08b\n&quot;,c)
	fmt.Printf(&quot;a^c: %08b\n&quot;,a ^ c)
}
</code></pre>

<p>给大家重点介绍下这个操作符 &amp;^，按位置零，例如：z = x &amp;^ y，表示如果 y 中的 bit 位为 1，则 z 对应 bit 位为 0，否则 z 对应 bit 位等于 x 中相应的 bit 位的值。</p>

<p>不知道大家发现没有，我们还可以这样理解或操作符 | ，表达式 z = x | y，如果 y 中的 bit 位为 1，则 z 对应 bit 位为 1，否则 z 对应 bit 位等于 x 中相应的 bit 位的值，与 &amp;^ 完全相反。</p>

<pre><code class="language-go">var x uint8 = 214
var y uint8 = 92
fmt.Printf(&quot;x: %08b\n&quot;,x)     
fmt.Printf(&quot;y: %08b\n&quot;,y)       
fmt.Printf(&quot;x | y: %08b\n&quot;,x | y)     
fmt.Printf(&quot;x &amp;^ y: %08b\n&quot;,x &amp;^ y)
</code></pre>

<p>输出：</p>

<pre><code class="language-go">x: 11010110
y: 01011100
x | y: 11011110
x &amp;^ y: 10000010
</code></pre>

<h3 id="第-49-天">第 49 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	var ch chan int
	select {
	case v, ok := &lt;-ch:
		println(v, ok)
	default:
		println(&quot;default&quot;) 
	}
}
</code></pre>

<p>参考答案及解析：default。ch 为 nil，读写都会阻塞。</p>

<p>2.下面这段代码输出什么？</p>

<pre><code class="language-go">type People struct {
	name string `json:&quot;name&quot;`
}

func main() {
	js := `{
		&quot;name&quot;:&quot;seekload&quot;
	}`
	var p People
	err := json.Unmarshal([]byte(js), &amp;p)
	if err != nil {
		fmt.Println(&quot;err: &quot;, err)
		return
	}
	fmt.Println(p)
}
</code></pre>

<p>参考答案及解析：输出 {}。知识点：结构体访问控制，因为 name 首字母是小写，导致其他包不能访问，所以输出为空结构体。修复代码：</p>

<pre><code class="language-go">type People struct {
	Name string `json:&quot;name&quot;`
}
</code></pre>

<h3 id="第-50-天">第 50 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">type T struct {
	ls []int
}

func foo(t T) {
	t.ls[0] = 100
}

func main() {
	var t = T{
		ls: []int{1, 2, 3},
	}

	foo(t)
	fmt.Println(t.ls[0])
}
</code></pre>

<ul>
<li>A. 1</li>
<li>B. 100</li>
<li>C. compilation error</li>
</ul>

<p>参考答案及解析：B。调用 foo() 函数时虽然是传值，但 foo() 函数中，字段 ls 依旧可以看成是指向底层数组的指针。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	isMatch := func(i int) bool {
		switch(i) {
		case 1:
		case 2:
			return true
		}
		return false
	}

	fmt.Println(isMatch(1))
	fmt.Println(isMatch(2))
}
</code></pre>

<p>参考答案及解析：false true。Go 语言的 switch 语句虽然没有&rdquo;break&rdquo;
，但如果 case 完成程序会默认 break，可以在 case 语句后面加上关键字 fallthrough，这样就会接着走下一个 case 语句（不用匹配后续条件表达式）。或者，利用 case 可以匹配多个值的特性。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	isMatch := func(i int) bool {
		switch(i) {
		case 1:
			fallthrough
		case 2:
			return true
		}
		return false
	}

	fmt.Println(isMatch(1))     // true
	fmt.Println(isMatch(2))     // true
	
	match := func(i int) bool {
		switch(i) {
		case 1,2:
			return true
		}
		return false
	}

	fmt.Println(match(1))       // true
	fmt.Println(match(2))       // true
}
</code></pre>

<h3 id="第-51-天">第 51 天</h3>

<p>1.下面的代码能否正确输出？</p>

<pre><code class="language-go">func main() {
	var fn1 = func() {}
	var fn2 = func() {}

	if fn1 != fn2 {
		println(&quot;fn1 not equal fn2&quot;)
	}
}
</code></pre>

<p>参考答案及解析：编译错误</p>

<pre><code class="language-go">invalid operation: fn1 != fn2 (func can only be compared to nil)
</code></pre>

<p>函数只能与 nil 比较。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">type T struct {
	n int
}

func main() {
	m := make(map[int]T)
	m[0].n = 1
	fmt.Println(m[0].n)
}
</code></pre>

<ul>
<li>A. 1</li>
<li>B. compilation error</li>
</ul>

<p>参考答案及解析：B。编译错误：</p>

<pre><code class="language-go">cannot assign to struct field m[0].n in map
</code></pre>

<p>map[key]struct 中 struct 是不可寻址的，所以无法直接赋值。</p>

<p>修复代码：</p>

<pre><code class="language-go">type T struct {
	n int
}

func main() {
	m := make(map[int]T)

	t := T{1}
	m[0] = t
	fmt.Println(m[0].n)
}
</code></pre>

<h3 id="第-52-天">第 52 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-go">type X struct {}

func (x *X) test()  {
	println(x)
}

func main() {

	var a *X
	a.test()

	X{}.test()
}
</code></pre>

<p>参考答案及解析：X{} 是不可寻址的，不能直接调用方法。知识点：在方法中，指针类型的接收者必须是合法指针（包括 nil）,或能获取实例地址。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {

	var a *X
	a.test()    // 相当于 test(nil)

	var x = X{}
	x.test()
}
</code></pre>

<p>引自：《Go语言学习笔记》· 方法</p>

<p>2.下面代码有什么不规范的地方吗？</p>

<pre><code class="language-go">func main() {
	x := map[string]string{&quot;one&quot;:&quot;a&quot;,&quot;two&quot;:&quot;&quot;,&quot;three&quot;:&quot;c&quot;}

	if v := x[&quot;two&quot;]; v == &quot;&quot; { 
		fmt.Println(&quot;no entry&quot;)
	}
}
</code></pre>

<p>参考答案及解析：检查 map 是否含有某一元素，直接判断元素的值并不是一种合适的方式。最可靠的操作是使用访问 map 时返回的第二个值。</p>

<p>修复代码如下：</p>

<pre><code class="language-go">func main() {  
    x := map[string]string{&quot;one&quot;:&quot;a&quot;,&quot;two&quot;:&quot;&quot;,&quot;three&quot;:&quot;c&quot;}

    if _,ok := x[&quot;two&quot;]; !ok {
        fmt.Println(&quot;no entry&quot;)
    }
}
</code></pre>

<p>引自：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html</a></p>

<h3 id="第-53-天">第 53 天</h3>

<p>1.关于 channel 下面描述正确的是？</p>

<ul>
<li>A. 向已关闭的通道发送数据会引发 panic；</li>
<li>B. 从已关闭的缓冲通道接收数据，返回已缓冲数据或者零值；</li>
<li>C. 无论接收还是接收，nil 通道都会阻塞；</li>
</ul>

<p>参考答案及解析：ABC。</p>

<p>2.下面的代码有几处问题？请详细说明。</p>

<pre><code class="language-go">type T struct {
	n int
}

func (t *T) Set(n int) {
	t.n = n
}

func getT() T {
	return T{}
}

func main() {
	getT().Set(1)
}
</code></pre>

<p>参考答案及解析：有两处问题：</p>

<ul>
<li>1.直接返回的 T{} 不可寻址；</li>
<li>2.不可寻址的结构体不能调用带结构体指针接收者的方法；</li>
</ul>

<p>修复代码：</p>

<pre><code class="language-go">type T struct {
	n int
}

func (t *T) Set(n int) {
	t.n = n
}

func getT() T {
	return T{}
}

func main() {
	t := getT()
	t.Set(2)
	fmt.Println(t.n)
}
</code></pre>

<h3 id="第-54-天">第 54 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-go">func (n N) value(){
	n++
	fmt.Printf(&quot;v:%p,%v\n&quot;,&amp;n,n)
}

func (n *N) pointer(){
	*n++
	fmt.Printf(&quot;v:%p,%v\n&quot;,n,*n)
}


func main() {

	var a N = 25

	p := &amp;a
	p1 := &amp;p

	p1.value()
	p1.pointer()
}
</code></pre>

<p>参考答案及解析：编译错误：</p>

<pre><code class="language-go">calling method value with receiver p1 (type **N) requires explicit dereference
calling method pointer with receiver p1 (type **N) requires explicit dereference
</code></pre>

<p>不能使用多级指针调用方法。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">type N int

func (n N) test(){
	fmt.Println(n)
}

func main()  {
	var n N = 10
	fmt.Println(n)

	n++
	f1 := N.test
	f1(n)

	n++
	f2 := (*N).test
	f2(&amp;n)
}
</code></pre>

<p>参考答案及解析：10 11 12。知识点：方法表达式。通过类型引用的方法表达式会被还原成普通函数样式，接收者是第一个参数，调用时显示传参。类型可以是 T 或 *T，只要目标方法存在于该类型的方法集中就可以。</p>

<p>还可以直接使用方法表达式调用：</p>

<pre><code class="language-go">func main()  {
	var n N = 10

	fmt.Println(n)

	n++
	N.test(n)

	n++
	(*N).test(&amp;n)
}
</code></pre>

<p>引自：《Go语言学习笔记》· 方法</p>

<h3 id="第-55-天">第 55 天</h3>

<p>1.关于 channel 下面描述正确的是？</p>

<ul>
<li>A. close() 可以用于只接收通道；</li>
<li>B. 单向通道可以转换为双向通道；</li>
<li>C. 不能在单向通道上做逆向操作（例如：只发送通道用于接收）；</li>
</ul>

<p>参考答案及解析：C。</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">type T struct {
	n int
}

func getT() T {
	return T{}
}

func main() {
	getT().n = 1
}
</code></pre>

<p>参考答案及解析：编译错误：</p>

<pre><code class="language-go">cannot assign to getT().n
</code></pre>

<p>直接返回的 T{} 无法寻址，不可直接赋值。</p>

<p>修复代码：</p>

<pre><code class="language-go">type T struct {
	n int
}

func getT() T {
	return T{}
}

func main() {
	t := getT()
	p := &amp;t.n    // &lt;=&gt; p = &amp;(t.n)
	*p = 1
	fmt.Println(t.n)
}
</code></pre>

<h3 id="第-56-天">第 56 天</h3>

<p>1.下面的代码有什么问题？</p>

<pre><code class="language-Go">package main

import &quot;fmt&quot;

func main() {
	s := make([]int, 3, 9)
	fmt.Println(len(s)) 
	s2 := s[4:8]
	fmt.Println(len(s2)) 
}
</code></pre>

<p>参考答案及解析：代码没问题，输出 3 4。<strong>从一个基础切片派生出的子切片的长度可能大于基础切片的长度</strong>。假设基础切片是 baseSlice，使用操作符 [low,high]，有如下规则：0 &lt;= low &lt;= high &lt;= cap(baseSlice)，只要上述满足这个关系，下标 low 和 high 都可以大于 len(baseSlice)。</p>

<p>引自：《Go语言101》</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">type N int

func (n N) test(){
	fmt.Println(n)
}

func main()  {
	var n N = 10
	p := &amp;n

	n++
	f1 := n.test

	n++
	f2 := p.test

	n++
	fmt.Println(n)

	f1()
	f2()
}
</code></pre>

<p>参考答案及解析：13 11 12。知识点：方法值。当指针值赋值给变量或者作为函数参数传递时，会立即计算并复制该方法执行所需的接收者对象，与其绑定，以便在稍后执行时，能隐式第传入接收者参数。</p>

<p>引自：《Go语言学习笔记》· 方法</p>

<h3 id="第-57-天">第 57 天</h3>

<p>1.下面哪一行代码会 panic，请说明原因？</p>

<pre><code class="language-go">package main

func main() {
  var x interface{}
  var y interface{} = []int{3, 5}
  _ = x == x
  _ = x == y
  _ = y == y
}
</code></pre>

<p>参考答案及解析：第 8 行。因为两个比较值的动态类型为同一个不可比较类型。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">var o = fmt.Print

func main() {
	c := make(chan int, 1)
	for range [3]struct{}{} {
		select {
		default:
			o(1)
		case &lt;-c:
			o(2)
			c = nil
		case c &lt;- 1:
			o(3)
		}
	}
}
</code></pre>

<p>参考答案及解析：321。第一次循环，写操作已经准备好，执行 o(3)，输出 3；第二次，读操作准备好，执行 o(2)，输出 2 并将 c 赋值为 nil；第三次，由于 c 为 nil，走的是 default 分支，输出 1。</p>

<p>两题均引自：《Go语言101》</p>

<h3 id="第-58-天">第 58 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">type T struct {
	x int
	y *int
}

func main() {

	i := 20
	t := T{10,&amp;i}

	p := &amp;t.x

	*p++
	*p--

	t.y = p

	fmt.Println(*t.y)
}
</code></pre>

<p>参考答案及解析：10。知识点：运算符优先级。如下规则：递增运算符 ++ 和递减运算符 &ndash; 的优先级低于解引用运算符 * 和取址运算符 &amp;，解引用运算符和取址运算符的优先级低于选择器 . 中的属性选择操作符。</p>

<p>2.下面哪一行代码会 panic，请说明原因？</p>

<pre><code class="language-go">package main

func main() {
	x := make([]int, 2, 10)
	_ = x[6:10]
	_ = x[6:]
	_ = x[2:]
}
</code></pre>

<p>参考答案：第 6 行，截取符号 [i:j]，如果 j 省略，默认是原切片或者数组的长度，x 的长度是 2，小于起始下标 6 ，所以 panic。</p>

<p>两题均引自：《Go语言101》</p>

<h3 id="第-59-天">第 59 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">type N int

func (n *N) test(){
	fmt.Println(*n)
}

func main()  {
	var n N = 10
	p := &amp;n

	n++
	f1 := n.test

	n++
	f2 := p.test

	n++
	fmt.Println(n)

	f1()
	f2()
}
</code></pre>

<p>参考答案及解析：13 13 13。知识点：方法值。当目标方法的接收者是指针类型时，那么被复制的就是指针。</p>

<p>引自：《Go语言学习笔记》· 方法</p>

<p>2.下面哪一行代码会 panic，请说明原因？</p>

<pre><code class="language-go">package main

func main() {
  var m map[int]bool // nil
  _ = m[123]
  var p *[5]string // nil
  for range p {
    _ = len(p)
  }
  var s []int // nil
  _ = s[:]
  s, s[0] = []int{1, 2}, 9
}
</code></pre>

<p>参考答案及解析：第 12 行。因为左侧的 s[0] 中的 s 为 nil。</p>

<p>引自：《Go语言101》</p>

<h3 id="第-60-天">第 60 天</h3>

<p>1.下面哪一行代码会 panic，请说明原因？</p>

<pre><code class="language-go">package main

type T struct{}

func (*T) foo() {
}

func (T) bar() {
}

type S struct {
  *T
}

func main() {
  s := S{}
  _ = s.foo
  s.foo()
  _ = s.bar
}
</code></pre>

<p>参考答案及解析：第 19 行，因为 s.bar 将被展开为 (*s.T).bar，而 s.T 是个空指针，解引用会 panic。</p>

<p>可以使用下面代码输出 s：</p>

<pre><code class="language-go">func main() {
	s := S{}
	fmt.Printf(&quot;%#v&quot;,s)   // 输出：main.S{T:(*main.T)(nil)}
}
</code></pre>

<p>引自：《Go语言101》</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">type data struct {
	sync.Mutex
}

func (d data) test(s string)  {
	d.Lock()
	defer d.Unlock()

	for i:=0;i&lt;5 ;i++  {
		fmt.Println(s,i)
		time.Sleep(time.Second)
	}
}


func main() {
	
	var wg sync.WaitGroup
	wg.Add(2)
	var d data

	go func() {
		defer wg.Done()
		d.test(&quot;read&quot;)
	}()

	go func() {
		defer wg.Done()
		d.test(&quot;write&quot;)
	}()

	wg.Wait()
}
</code></pre>

<p>参考答案及解析：锁失效。将 Mutex 作为匿名字段时，相关的方法必须使用指针接收者，否则会导致锁机制失效。</p>

<p>修复代码：</p>

<pre><code class="language-go">func (d *data) test(s string)  {     // 指针接收者
	d.Lock()
	defer d.Unlock()

	for i:=0;i&lt;5 ;i++  {
		fmt.Println(s,i)
		time.Sleep(time.Second)
	}
}
</code></pre>

<p>或者可以通过嵌入 *Mutex 来避免复制的问题，但需要初始化。</p>

<pre><code class="language-go">type data struct {
	*sync.Mutex     // *Mutex
}

func (d data) test(s string) {    // 值方法
	d.Lock()
	defer d.Unlock()

	for i := 0; i &lt; 5; i++ {
		fmt.Println(s, i)
		time.Sleep(time.Second)
	}
}

func main() {

	var wg sync.WaitGroup
	wg.Add(2)

	d := data{new(sync.Mutex)}   // 初始化

	go func() {
		defer wg.Done()
		d.test(&quot;read&quot;)
	}()

	go func() {
		defer wg.Done()
		d.test(&quot;write&quot;)
	}()

	wg.Wait()
}
</code></pre>

<p>引自：《Go 语言学习笔记》· 同步</p>

<h3 id="第-61-天">第 61 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	var k = 1
	var s = []int{1, 2}
	k, s[k] = 0, 3
	fmt.Println(s[0] + s[1])
}
</code></pre>

<p>参考答案及解析：4。知识点：多重赋值。</p>

<p>多重赋值分为两个步骤，有先后顺序：<br></p>

<ul>
<li>计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；</li>
<li>赋值；</li>
</ul>

<p>所以本例，会先计算 s[k]，等号右边是两个表达式是常量，所以赋值运算等同于 <code>k, s[0] = 0, 3</code>。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	var k = 9
	for k = range []int{} {}
	fmt.Println(k)

	for k = 0; k &lt; 3; k++ {
	}
	fmt.Println(k)


	for k = range (*[3]int)(nil) {
	}
	fmt.Println(k)
}
</code></pre>

<p>参考答案及解析：932。</p>

<h3 id="第-62-天">第 62 天</h3>

<p>1.下面哪一行代码会 panic，请说明。</p>

<pre><code class="language-go">func main() {
	nil := 123
	fmt.Println(nil)
	var _ map[string]int = nil
}
</code></pre>

<p>参考答案及解析：第 4 行，当前作用域中，预定义的 nil 被覆盖，此时 nil 是 int 类型值，不能赋值给 map 类型。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	var x int8 = -128
	var y = x/-1
	fmt.Println(y)
}
</code></pre>

<p>参考答案及解析：-128。因为溢出。</p>

<h3 id="第-63-天">第 63 天</h3>

<p>1.下面选项正确的是？</p>

<ul>
<li>A. 类型可以声明的函数体内；</li>
<li>B. Go 语言支持 ++i 或者 &ndash;i 操作；</li>
<li>C. nil 是关键字；</li>
<li>D. 匿名函数可以直接赋值给一个变量或者直接执行；</li>
</ul>

<p>参考答案及解析：AD。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">func F(n int) func() int {
	return func() int {
		n++
		return n
	}
}

func main() {
	f := F(5)
	defer func() {
		fmt.Println(f())
	}()
	defer fmt.Println(f())
	i := f()
	fmt.Println(i)
}
</code></pre>

<p>参考答案及解析：768。知识点：匿名函数、defer()。defer() 后面的函数如果带参数，会优先计算参数，并将结果存储在栈中，到真正执行 defer() 的时候取出。</p>

<p>引自《Go语言101》</p>

<h3 id="第-64-天">第 64 天</h3>

<p>1.下面列举的是 recover() 的几种调用方式，哪些是正确的？</p>

<ul>
<li>A.</li>
</ul>

<pre><code class="language-go">func main() {
	recover()
	panic(1)
}
</code></pre>

<ul>
<li>B.</li>
</ul>

<pre><code class="language-go">func main() {
	defer recover()
	panic(1)
}
</code></pre>

<ul>
<li>C.</li>
</ul>

<pre><code class="language-go">func main() {
	defer func() {
		recover()
	}()
	panic(1)
}
</code></pre>

<ul>
<li>D.</li>
</ul>

<pre><code class="language-go">func main() {
	defer func() {
		defer func() {
			recover()
		}()
	}()
	panic(1)
}
</code></pre>

<p>参考答案及解析：C。recover() 必须在 defer() 函数中直接调用才有效。上面其他几种情况调用都是无效的：直接调用 recover()、在 defer() 中直接调用 recover() 和 defer() 调用时多层嵌套。</p>

<p>2.下面代码输出什么，请说明？</p>

<pre><code class="language-go">func main() {
	defer func() {
		fmt.Print(recover())
	}()
	defer func() {
		defer fmt.Print(recover())
		panic(1)
	}()
	defer recover() 
	panic(2)
}
</code></pre>

<p>参考答案及解析：21。recover() 必须在 defer() 函数中调用才有效，所以第 9 行代码捕获是无效的。在调用 defer() 时，便会计算函数的参数并压入栈中，所以执行第 6 行代码时，此时便会捕获 panic(2)；此后的 panic(1)，会被上一层的 recover() 捕获。所以输出 21。</p>

<p>引自《Go语言101》</p>

<h3 id="第-65-天">第 65 天</h3>

<p>1.flag 是 bool 型变量，下面 if 表达式符合编码规范的是？</p>

<ul>
<li>A. if flag == 1</li>
<li>B. if flag</li>
<li>C. if flag == false</li>
<li>D. if !flag</li>
</ul>

<p>参考答案及解析：BCD。</p>

<p>2.下面的代码输出什么，请说明？</p>

<pre><code class="language-go">func main() {
	defer func() {
		fmt.Print(recover())
	}()
	defer func() {
		defer func() {
			fmt.Print(recover())
		}()
		panic(1)
	}()
	defer recover()
	panic(2)
}
</code></pre>

<p>参考答案及解析：12。解析请看前一天的题目。</p>

<h3 id="第-66-天">第 66 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">type T struct {
	n int
}

func main() {
	ts := [2]T{}
	for i, t := range ts {
		switch i {
		case 0:
			t.n = 3
			ts[1].n = 9
		case 1:
			fmt.Print(t.n, &quot; &quot;)
		}
	}
	fmt.Print(ts)
}
</code></pre>

<p>参考答案及解析：0 [{0} {9}]。知识点：for-range 循环数组。此时使用的是数组 ts 的副本，所以 t.n = 3 的赋值操作不会影响原数组。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">type T struct {
	n int
}

func main() {
	ts := [2]T{}
	for i, t := range &amp;ts {
		switch i {
		case 0:
			t.n = 3
			ts[1].n = 9
		case 1:
			fmt.Print(t.n, &quot; &quot;)
		}
	}
	fmt.Print(ts)
}
</code></pre>

<p>参考答案及解析：9 [{0} {9}]。知识点：for-range 数组指针。for-range 循环中的循环变量 t 是原数组元素的副本。如果数组元素是结构体值，则副本的字段和原数组字段是两个不同的值。</p>

<h3 id="第-67-天">第 67 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">type T struct {
	n int
}

func main() {
	ts := [2]T{}
	for i := range ts[:] {
		switch i {
		case 0:
			ts[1].n = 9
		case 1:
			fmt.Print(ts[i].n, &quot; &quot;)
		}
	}
	fmt.Print(ts)
}
</code></pre>

<p>参考答案及解析：9 [{0} {9}]。知识点：for-range 切片。for-range 切片时使用的是切片的副本，但不会复制底层数组，换句话说，此副本切片与原数组共享底层数组。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">type T struct {
	n int
}

func main() {
	ts := [2]T{}
	for i := range ts[:] {
		switch t := &amp;ts[i]; i {
		case 0:
			t.n = 3;
			ts[1].n = 9
		case 1:
			fmt.Print(t.n, &quot; &quot;)
		}
	}
	fmt.Print(ts)
}
</code></pre>

<p>参考答案及解析：9 [{3} {9}]。知识点：for-range 切片。</p>

<h3 id="第-68-天">第 68 天</h3>

<p>1.下面代码有什么问题吗？</p>

<pre><code class="language-go">func main()  {

	for i:=0;i&lt;10 ;i++  {
	loop:
		println(i)
	}
	goto loop
}
</code></pre>

<p>参考答案及解析：goto 不能跳转到其他函数或者内层代码。编译报错：</p>

<pre><code class="language-go">goto loop jumps into block starting at
</code></pre>

<p>2.下面代码输出什么，请说明。</p>

<pre><code class="language-go">func main() {
	x := []int{0, 1, 2}
	y := [3]*int{}
	for i, v := range x {
		defer func() {
			print(v)
		}()
		y[i] = &amp;v
	}
	print(*y[0], *y[1], *y[2])
}
</code></pre>

<p>参考答案及解析：22222。知识点：defer()、for-range。for-range 虽然使用的是 :=，但是 v 不会重新声明，可以打印 v 的地址验证下。</p>

<h3 id="第-69-天">第 69 天</h3>

<p>1.关于 slice 或 map 操作，下面正确的是？</p>

<ul>
<li>A</li>
</ul>

<pre><code class="language-go">var s []int
s = append(s,1)
</code></pre>

<ul>
<li>B</li>
</ul>

<pre><code class="language-go">var m map[string]int
m[&quot;one&quot;] = 1 
</code></pre>

<ul>
<li>C</li>
</ul>

<pre><code class="language-go">var s []int
s = make([]int, 0)
s = append(s,1)
</code></pre>

<ul>
<li>D</li>
</ul>

<pre><code class="language-go">var m map[string]int
m = make(map[string]int)
m[&quot;one&quot;] = 1 
</code></pre>

<p>参考答案及解析：ACD。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func test(x int) (func(), func()) {
	return func() {
		println(x)
		x += 10
	}, func() {
		println(x)
	}
}

func main() {
	a, b := test(100)
	a()
	b()
}
</code></pre>

<p>参考答案及解析：100 110。知识点：闭包引用相同变量。</p>

<h3 id="第-70-天">第 70 天</h3>

<p>1.关于字符串连接，下面语法正确的是？</p>

<ul>
<li>A. str := &lsquo;abc&rsquo; + &lsquo;123&rsquo;</li>
<li>B. str := &ldquo;abc&rdquo; + &ldquo;123&rdquo;</li>
<li>C. str ：= &lsquo;123&rsquo; + &ldquo;abc&rdquo;</li>
<li>D. fmt.Sprintf(&ldquo;abc%d&rdquo;, 123)</li>
</ul>

<p>参考答案及解析：BD。知识点：单引号、双引号和字符串连接。在 Go 语言中，双引号用来表示字符串 string，其实质是一个 byte 类型的数组，单引号表示 rune 类型。</p>

<p>2.下面代码能编译通过吗？可以的话，输出什么？</p>

<pre><code class="language-go">func main() {

	println(DeferTest1(1))
	println(DeferTest2(1))
}

func DeferTest1(i int) (r int) {
	r = i
	defer func() {
		r += 3
	}()
	return r
}

func DeferTest2(i int) (r int) {
	defer func() {
		r += i
	}()
	return 2
}
</code></pre>

<p>参考答案及解析：43。具体解析请看《5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！》。
引自：<a href="https://my.oschina.net/qiangmzsx/blog/1515173">https://my.oschina.net/qiangmzsx/blog/1515173</a></p>

<h3 id="第-71-天">第 71 天</h3>

<p>1.判断题：对变量x的取反操作是 ~x？</p>

<p>从参考答案及解析：错。Go 语言的取反操作是 ^，它返回一个每个 bit 位都取反的数。作用类似在 C、C#、Java 语言中中符号 ~，对于有符号的整数来说，是按照补码进行取反操作的（快速计算方法：对数 a 取反，结果为 -(a+1) ），对于无符号整数来说就是按位取反。</p>

<p>2.下面代码输出什么，请说明原因。</p>

<pre><code class="language-go">type Slice []int

func NewSlice() Slice {
	return make(Slice, 0)
}
func (s *Slice) Add(elem int) *Slice {
	*s = append(*s, elem)
	fmt.Print(elem)
	return s
}
func main() {
	s := NewSlice()
	defer s.Add(1).Add(2)
	s.Add(3)
}
</code></pre>

<p>参考答案及解析：132。这一题有两点需要注意：1.Add() 方法的返回值依然是指针类型 *Slice，所以可以循环调用方法 Add()；2.defer 函数的参数（包括接受者）是在 defer 语句出现的位置做计算的，而不是在函数正在执行的时候计算的，所以 s.Add(1) 会先于 s.Add(3) 执行。</p>

<h3 id="第-72-天">第 72 天</h3>

<p>1.下面的代码输出什么，请说明。</p>

<pre><code class="language-go">type Slice []int

func NewSlice() Slice {
	return make(Slice, 0)
}
func (s *Slice) Add(elem int) *Slice {
	*s = append(*s, elem)
	fmt.Print(elem)
	return s
}
func main() {
	s := NewSlice()
	defer func() {
		s.Add(1).Add(2)
	}()
	s.Add(3)
}
</code></pre>

<p>参考答案及解析：312。对比昨天的第二题，本题的 s.Add(1).Add(2) 作为一个整体包在一个匿名函数中，会延迟执行。</p>

<p>2.下面的代码输出什么，请说明？</p>

<pre><code class="language-go">type Orange struct {
	Quantity int
}

func (o *Orange) Increase(n int) {
	o.Quantity += n
}

func (o *Orange) Decrease(n int) {
	o.Quantity -= n
}

func (o *Orange) String() string {
	return fmt.Sprintf(&quot;%#v&quot;, o.Quantity)
}

func main() {
	var orange Orange
	orange.Increase(10)
	orange.Decrease(5)
	fmt.Println(orange)
}
</code></pre>

<p>参考答案及解析：{5}。这道题容易忽视的点是，String() 是指针方法，而不是值方法，所以使用 Println() 输出时不会调用到 String() 方法。</p>

<p>可以这样修复：</p>

<pre><code class="language-go">func main() {
	orange := &amp;Orange{}
	orange.Increase(10)
	orange.Decrease(5)
	fmt.Println(orange)
}
</code></pre>

<h3 id="第-73-天">第 73 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func test() []func() {
	var funs []func()
	for i := 0; i &lt; 2; i++ {
		funs = append(funs, func() {
			println(&amp;i, i)
		})
	}
	return funs
}

func main() {
	funs := test()
	for _, f := range funs {
		f()
	}
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">0xc000018058 2
0xc000018058 2
</code></pre>

<p>知识点：闭包延迟求值。for 循环局部变量 i，匿名函数每一次使用的都是同一个变量。</p>

<p>如果想要匿名函数每一次输出不同，应该怎么修改代码？</p>

<p>引自：<a href="https://my.oschina.net/qiangmzsx/blog/1533839">https://my.oschina.net/qiangmzsx/blog/1533839</a></p>

<p>2.下面的代码能编译通过吗？可以的话输出什么，请说明？</p>

<pre><code class="language-go">var f = func(i int) {
	print(&quot;x&quot;)
}

func main() {
	f := func(i int) {
		print(i)
		if i &gt; 0 {
			f(i - 1)
		}
	}
	f(10)
}
</code></pre>

<p>参考答案及解析：10x。这道题一眼看上去会输出 109876543210，其实这是错误的答案，这里不是递归。假设 main() 函数里为 f2()，外面的为 f1()，当声明 f2() 时，调用的是已经完成声明的 f1()。</p>

<p>看下面这段代码你应该会更容易理解一点：</p>

<pre><code class="language-go">var x = 23

func main() {
	x := 2*x - 4
	println(x)    // 输出:42
}
</code></pre>

<h3 id="第-74-天">第 74 天</h3>

<p>1.下面代码有什么问题，请说明？</p>

<pre><code class="language-go">func main() {
	runtime.GOMAXPROCS(1)

	go func() {
		for i:=0;i&lt;10 ;i++  {
			fmt.Println(i)
		}
	}()

	for {}
}
</code></pre>

<p>参考答案及解析：for {} 独占 CPU 资源导致其他 Goroutine 饿死。</p>

<p>可以通过阻塞的方式避免 CPU 占用，修复代码：</p>

<pre><code>func main() {
	runtime.GOMAXPROCS(1)

	go func() {
		for i:=0;i&lt;10 ;i++  {
			fmt.Println(i)
		}
		os.Exit(0)
	}()

	select {}
}
</code></pre>

<p>引自《Go语言高级编程》</p>

<p>2.假设 x 已声明，y 未声明，下面 4 行代码哪些是正确的。错误的请说明原因？</p>

<pre><code class="language-go">x, _ := f()  // 1
x, _ = f()  // 2
x, y := f()  // 3
x, y = f()  // 4
</code></pre>

<p>参考答案及解析：2、3正确。知识点：简短变量声明。使用简短变量声明有几个需要注意的地方：</p>

<ul>
<li>只能用于函数内部；</li>
<li>短变量声明语句中至少要声明一个新的变量；</li>
</ul>

<h3 id="第-75-天">第 75 天</h3>

<p>1.下面的代码有什么问题，请说明？</p>

<pre><code class="language-go">func main() {
	f, err := os.Open(&quot;file&quot;)
	defer f.Close()
	if err != nil {
		return
	}

	b, err := ioutil.ReadAll(f)
	println(string(b))
}
</code></pre>

<p>参考答案及解析：defer 语句应该放在 if() 语句后面，先判断 err，再 defer 关闭文件句柄。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	f, err := os.Open(&quot;file&quot;)
	if err != nil {
		return
	}
	defer f.Close()

	b, err := ioutil.ReadAll(f)
	println(string(b))
}
</code></pre>

<p>2.下面代码输出什么，为什么？</p>

<pre><code class="language-go">func f() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf(&quot;recover:%#v&quot;, r)
		}
	}()
	panic(1)
	panic(2)
}

func main() {
	f()
}
</code></pre>

<p>参考答案及解析：recover:1。知识点：panic、recover()。当程序 panic 时就不会往下执行，可以使用 recover() 捕获 panic 的内容。</p>

<h3 id="第-76-天">第 76 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">type S1 struct{}

func (s1 S1) f() {
	fmt.Println(&quot;S1.f()&quot;)
}
func (s1 S1) g() {
	fmt.Println(&quot;S1.g()&quot;)
}

type S2 struct {
	S1
}

func (s2 S2) f() {
	fmt.Println(&quot;S2.f()&quot;)
}

type I interface {
	f()
}

func printType(i I) {
	
	fmt.Printf(&quot;%T\n&quot;, i)
	if s1, ok := i.(S1); ok {
		s1.f()
		s1.g()
	}
	if s2, ok := i.(S2); ok {
		s2.f()
		s2.g()
	}
}

func main() {
	printType(S1{})
	printType(S2{})
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">main.S1
S1.f()
S1.g()
main.S2
S2.f()
S1.g()
</code></pre>

<p>知识点：类型断言，结构体嵌套。结构体 S2 嵌套了结构体 S1，S2 自己没有实现 g() ，调用的是 S1 的 g()。</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		fmt.Println(&quot;1&quot;)
		wg.Done()
		wg.Add(1)
	}()
	wg.Wait()
}
</code></pre>

<p>参考答案及解析：协程里面，使用 wg.Add(1) 但是没有 wg.Done()，导致 panic()。</p>

<h3 id="第-77-天">第 77 天</h3>

<p>1.关于 cap 函数适用下面哪些类型？</p>

<ul>
<li>A. 数组；</li>
<li>B. channel;</li>
<li>C. map；</li>
<li>D. slice；</li>
</ul>

<p>参考答案即解析：ABD。cap() 函数的作用：
- arry 返回数组的元素个数；
- slice 返回 slice 的最大容量；
- channel 返回 channel 的容量；</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func hello(num ...int) {
	num[0] = 18
}

func Test13(t *testing.T) {
	i := []int{5, 6, 7}
	hello(i...)
	fmt.Println(i[0])
}

func main() {
	t := &amp;testing.T{}
	Test13(t)
}
</code></pre>

<ul>
<li>A. 18</li>
<li>B. 5</li>
<li>C. Compilation error</li>
</ul>

<p>参考答案及解析：A。可变函数是指针传递。</p>

<h3 id="第-78-天">第 78 天</h3>

<p>1.关于 switch 语句，下面说法正确的是？</p>

<ul>
<li>A. 单个 case 中，可以出现多个结果选项；</li>
<li>B. 需要使用 break 来明确退出一个 case;</li>
<li>C. 只有在 case 中明确添加 fallthrought 关键字，才会继续执行紧跟的下一个 case;</li>
<li>D. 条件表达式必须为常量或者整数；</li>
</ul>

<p>参考答案及解析：AC。</p>

<p>2.下面代码能编译通过吗？可以的话，输出什么？</p>

<pre><code class="language-go">func alwaysFalse() bool {
	return false
}

func main() {
	switch alwaysFalse()
	{
	case true:
		println(true)
	case false:
		println(false)
	}
}
</code></pre>

<p>参考答案及解析：可以编译通过，输出：true。知识点：Go 代码断行规则。</p>

<p>详情请查看：
<a href="https://gfw.go101.org/article/line-break-rules.html">https://gfw.go101.org/article/line-break-rules.html</a></p>

<h3 id="第-79-天">第 79 天</h3>

<p>1.interface{} 是可以指向任意对象的 Any 类型，是否正确？</p>

<ul>
<li>A. false</li>
<li>B. true</li>
</ul>

<p>参考答案及解析：B。</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">type ConfigOne struct {
	Daemon string
}

func (c *ConfigOne) String() string {
	return fmt.Sprintf(&quot;print: %v&quot;, c)
}

func main() {
	c := &amp;ConfigOne{}
	c.String()
}
</code></pre>

<p>参考答案及解析：无限递归循环，栈溢出。知识点：类型的 String() 方法。如果类型定义了 String() 方法，使用 Printf()、Print() 、 Println() 、 Sprintf() 等格式化输出时会自动使用 String() 方法。</p>

<h3 id="第-80-天">第 80 天</h3>

<p>1.定义一个包内全局字符串变量，下面语法正确的是？</p>

<ul>
<li>A. var str string</li>
<li>B. str := &ldquo;&rdquo;</li>
<li>C. str = &ldquo;&rdquo;</li>
<li>D. var str = &ldquo;&rdquo;</li>
</ul>

<p>参考答案及解析：AD。全局变量要定义在函数之外，而在函数之外定义的变量只能用 var 定义。短变量声明 := 只能用于函数之内。</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">func main() {

	wg := sync.WaitGroup{}

	for i := 0; i &lt; 5; i++ {
		go func(wg sync.WaitGroup, i int) {
			wg.Add(1)
			fmt.Printf(&quot;i:%d\n&quot;, i)
			wg.Done()
		}(wg, i)
	}

	wg.Wait()

	fmt.Println(&quot;exit&quot;)
}
</code></pre>

<p>参考答案及解析：知识点：WaitGroup 的使用。存在两个问题：</p>

<ul>
<li>在协程中使用 wg.Add()；</li>
<li>使用了 sync.WaitGroup 副本；</li>
</ul>

<p>修复代码：</p>

<pre><code class="language-go">func main() {

	wg := sync.WaitGroup{}

	for i := 0; i &lt; 5; i++ {
		wg.Add(1)
		go func(i int) {
			fmt.Printf(&quot;i:%d\n&quot;, i)
			wg.Done()
		}(i)
	}

	wg.Wait()

	fmt.Println(&quot;exit&quot;)
}
</code></pre>

<p>或者：</p>

<pre><code class="language-go">func main() {

	wg := &amp;sync.WaitGroup{}

	for i := 0; i &lt; 5; i++ {
		wg.Add(1)
		go func(wg *sync.WaitGroup,i int) {
			fmt.Printf(&quot;i:%d\n&quot;, i)
			wg.Done()
		}(wg,i)
	}

	wg.Wait()

	fmt.Println(&quot;exit&quot;)
}
</code></pre>

<h3 id="第-81-天">第 81 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">func main() {
	var a []int = nil
	a, a[0] = []int{1, 2}, 9
	fmt.Println(a)
}
</code></pre>

<p>参考答案即解析：运行时错误。知识点：多重赋值。</p>

<p>多重赋值分为两个步骤，有先后顺序：<br></p>

<ul>
<li>计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；</li>
<li>赋值；</li>
</ul>

<p>2.下面代码中的指针 p 为野指针，因为返回的栈内存在函数结束时会被释放？</p>

<pre><code class="language-go">type TimesMatcher struct {
	base int
}

func NewTimesMatcher(base int) *TimesMatcher  {
	return &amp;TimesMatcher{base:base}
}

func main() {
	p := NewTimesMatcher(3)
	fmt.Println(p)
}
</code></pre>

<ul>
<li>A. false</li>
<li>B. true</li>
</ul>

<p>参考答案及解析：A。Go语言的内存回收机制规定，只要有一个指针指向引用一个变量，那么这个变量就不会被释放（内存逃逸），因此在 Go 语言中返回函数参数或临时变量是安全的。</p>

<h3 id="第-82-天">第 82 天</h3>

<p>1.下面这段代码输出什么？</p>

<pre><code class="language-go">func main() {
	count := 0
	for i := range [256]struct{}{} {
		m, n := byte(i), int8(i)
		if n == -n {
			count++
		}
		if m == -m {
			count++
		}
	}
	fmt.Println(count)
}
</code></pre>

<p>参考答案及解析：4。知识点：数值溢出。当 i 的值为 0、128 是会发生相等情况，注意 byte 是 uint8 的别名。</p>

<p>引自《Go语言101》</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">const (
	azero = iota
	aone  = iota
)

const (
	info  = &quot;msg&quot;
	bzero = iota
	bone  = iota
)

func main() {
	fmt.Println(azero, aone)
	fmt.Println(bzero, bone)
}
</code></pre>

<p>参考答案及解析：0 1 1 2。知识点：iota 的使用。这道题易错点在 bzero、bone 的值，在一个常量声明代码块中，如果 iota 没出现在第一行，则常量的初始值就是非 0 值。</p>

<h3 id="第-83-天">第 83 天</h3>

<p>1.同级文件的包名不允许有多个，是否正确？</p>

<ul>
<li>A. true</li>
<li>B. false</li>
</ul>

<p>参考答案及解析：A。一个文件夹下只能有一个包，可以多个.go文件，但这些文件必须属于同一个包。</p>

<p>2.下面的代码有什么问题，请说明。</p>

<pre><code class="language-go">type data struct {
	name string
}

func (p *data) print() {
	fmt.Println(&quot;name:&quot;, p.name)
}

type printer interface {
	print()
}

func main() {
	d1 := data{&quot;one&quot;}
	d1.print()

	var in printer = data{&quot;two&quot;}
	in.print()
}
</code></pre>

<p>参考答案及解析：编译报错。</p>

<pre><code class="language-go">cannot use data literal (type data) as type printer in assignment:
data does not implement printer (print method has pointer receiver)
</code></pre>

<p>结构体类型 data 没有实现接口 printer。知识点：接口。</p>

<h3 id="第-84-天">第 84 天</h3>

<p>1.函数执行时，如果由于 panic 导致了异常，则延迟函数不会执行。这一说法是否正确？</p>

<ul>
<li>A. true</li>
<li>B. false</li>
</ul>

<p>参考答案及解析：B。
由 panic 引发异常以后，程序停止执行，然后调用延迟函数（defer），就像程序正常退出一样。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	a := [3]int{0, 1, 2}
	s := a[1:2]

	s[0] = 11
	s = append(s, 12)
	s = append(s, 13)
	s[0] = 21
	
	fmt.Println(a)
	fmt.Println(s)
}
</code></pre>

<p>参考答案及解析：</p>

<p>输出：</p>

<pre><code class="language-go">[0 11 12]
[21 12 13]
</code></pre>

<h3 id="第-85-天">第 85 天</h3>

<p>1.下面这段代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	fmt.Println(strings.TrimRight(&quot;ABBA&quot;, &quot;BA&quot;))
}
</code></pre>

<p>参考答案及解析：输出空字符。这是一个大多数人遇到的坑，TrimRight() 会将第二个参数字符串里面所有的字符拿出来处理，只要与其中任何一个字符相等，便会将其删除。想正确地截取字符串，可以参考 TrimSuffix() 函数。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	var src, dst []int
	src = []int{1, 2, 3}
	copy(dst, src) 
	fmt.Println(dst)
}
</code></pre>

<p>参考答案及解析：输出 []。知识点：拷贝切片。copy(dst, src) 函数返回 len(dst)、len(src) 之间的最小值。如果想要将 src 完全拷贝至 dst，必须给 dst 分配足够的内存空间。</p>

<p>修复代码：</p>

<pre><code class="language-go">func main() {
	var src, dst []int
	src = []int{1, 2, 3}
	dst = make([]int, len(src))
	n := copy(dst, src)
	fmt.Println(n,dst)
}
</code></pre>

<p>或者直接使用 append()</p>

<pre><code class="language-go">func main() {
	var src, dst []int
	src = []int{1, 2, 3}
	dst = append(dst, src...)
	fmt.Println(&quot;dst:&quot;, dst)
}
</code></pre>

<h3 id="第-86-天">第 86 天</h3>

<p>1.n 是秒数，下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	n := 43210
	fmt.Println(n/60*60, &quot; hours and &quot;, n%60*60, &quot; seconds&quot;)
}
</code></pre>

<p>参考答案及解析：43200 hours and 600 seconds。知识点：运算符优先级。算术运算符 *、/ 和 % 的优先级相同，从左向右结合。</p>

<p>修复代码如下：</p>

<pre><code class="language-go">func main() {
	n := 43210
	fmt.Println(n/(60*60), &quot;hours and&quot;, n%(60*60), &quot;seconds&quot;)
}
</code></pre>

<p>2.下面代码输出什么，为什么？</p>

<pre><code class="language-go">const (
	Century = 100
	Decade  = 010
	Year    = 001
)

func main() {
	fmt.Println(Century + 2*Decade + 2*Year)
}
</code></pre>

<p>参考答案及解析：118。知识点：进制数。Go 语言里面，八进制数以 0 开头，十六进制数以 0x 开头，所以 Decade 表示十进制的 8。</p>

<h3 id="第-87-天">第 87 天</h3>

<p>1.关于协程，下面说法正确是()</p>

<ul>
<li>A.协程和线程都可以实现程序的并发执行；</li>
<li>B.线程比协程更轻量级；</li>
<li>C.协程不存在死锁问题；</li>
<li>D.通过 channel 来进行协程间的通信；</li>
</ul>

<p>参考答案及解析：AD。</p>

<p>2.在数学里面，有著名的勾股定理：</p>

<pre><code class="language-math">a^2+b^2=c^2
</code></pre>

<p>例如，有我们熟悉的组合（3，4，5）、（6、8、10）等。在 Go 语言中，下面代码输出 true：</p>

<pre><code class="language-go">fmt.Println(3^2+4^2 == 5^2) // true
</code></pre>

<p>问题来了，下面代码输出什么，请简要说明。</p>

<pre><code class="language-go">func main() {
	fmt.Println(6^2+8^2 == 10^2)
}
</code></pre>

<p>参考答案及解析：false。在 Go 语言里面，^ 作为二元运算符时表示<strong>按位异或</strong>：对应位，相同为 0，相异为 1。所以第一段代码输出 true 是因为：</p>

<pre><code class="language-go">0011 ^ 0010 == 0001   (3^2 == 1)
0100 ^ 0010 == 0110   (4^2 == 6)
0101 ^ 0010 == 0111   (5^2 == 7)
</code></pre>

<p>1+6=7，这当然是相等的。你来试试分解下第二段代码的数学表达式！</p>

<p>参考：<a href="https://yourbasic.org/golang/gotcha-bitwise-operators/">https://yourbasic.org/golang/gotcha-bitwise-operators/</a></p>

<h3 id="第-88-天">第 88 天</h3>

<p>1.下面这段代码能通过编译吗？请简要说明。</p>

<pre><code class="language-go">func main() {
    m := make(map[string]int)
    m[&quot;foo&quot;]++
    fmt.Println(m[&quot;foo&quot;])
}
</code></pre>

<p>参考答案及解析：能通过编译。</p>

<p>上面的代码可以理解成：</p>

<pre><code class="language-go">func main() {
    m := make(map[string]int)
    v := m[&quot;foo&quot;]
    v++
    m[&quot;foo&quot;] = v
    fmt.Println(m[&quot;foo&quot;])
}
</code></pre>

<p>2.下面的代码输出什么，请简要说明？</p>

<pre><code class="language-go">func Foo() error {
	var err *os.PathError = nil
	// …
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
</code></pre>

<p>参考答案及解析：nil false。知识点：接口值与 nil 值。只有在值和动态类型都为 nil 的情况下，接口值才为 nil。Foo() 函数返回的 err 变量，值为 nil、动态类型为 *os.PathError，与 nil（值为 nil，动态类型为 nil）显然是不相等。我们可以打印下变量 err 的详情：</p>

<pre><code class="language-go">fmt.Printf(&quot;%#v\n&quot;,err)   // (*os.PathError)(nil)
</code></pre>

<p>一个更合适的解决办法：</p>

<pre><code class="language-go">func Foo() (err error) {
	// …
	return
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
</code></pre>

<h3 id="第-89-天">第 89 天</h3>

<p>1.下面代码能编译通过吗？请简要说明。</p>

<pre><code class="language-go">func main() {
    v := []int{1, 2, 3}
    for i, n := 0, len(v); i &lt; n; i++ {
        v = append(v, i)
    }
    fmt.Println(v)
}
</code></pre>

<p>参考答案及解析：能编译通过，输出 [1 2 3 0 1 2]。for range 循环开始的时候，终止条件只会计算一次。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">type P *int
type Q *int

func main() {
	var p P = new(int)
	*p += 8
	var x *int = p
	var q Q = x
	*q++
	fmt.Println(*p, *q)
}
</code></pre>

<ul>
<li>A.8 8</li>
<li>B.8 9</li>
<li>C.9 9</li>
</ul>

<p>参考答案及解析：C。指针变量指向相同的地址。</p>

<h3 id="第-90-天">第 90 天</h3>

<p>1.下面代码能通过编译吗？</p>

<pre><code class="language-go">type T int

func F(t T) {}

func main() {
	var q int
	F(q)
}
</code></pre>

<p>2.下面代码能通过编译吗？请简要说明。</p>

<pre><code class="language-go">type T []int

func F(t T) {}

func main() {
    var q []int
    F(q)
}
</code></pre>

<p>我们将这两道题目放到一块做一个解析，第一题不能通过编译，第二题可以通过编译。我们知道不同类型的值是不能相互赋值的，即使底层类型一样，所以第一题编译不通过；对于底层类型相同的变量可以相互赋值还有一个重要的条件，即至少有一个不是有名类型（named type）。</p>

<p>这是 Go 语言规范手册的原文：
&gt;&ldquo;x&rsquo;s type V and T have identical underlying types and at least one of V or T is not a named type. &ldquo;</p>

<p>Named Type 有两类：</p>

<ul>
<li>内置类型，比如 int, int64, float, string, bool 等；</li>
<li>使用关键字 type 声明的类型；</li>
</ul>

<p>Unnamed Type 是基于已有的 Named Type 组合一起的类型，例如：struct{}、[]string、interface{}、map[string]bool 等。</p>

<p>引自：<a href="https://mp.weixin.qq.com/s?__biz=MzA3MjIwNzYyNA==&amp;mid=2650918436&amp;idx=1&amp;sn=094e9c52fe922415a64297a18fcc1bb4&amp;chksm=84d4b243b3a33b55aa6bb99c495fe4156659c1ac1e0d8312b232054b51a26f041a32b4929f4a#rd">https://mp.weixin.qq.com/s?__biz=MzA3MjIwNzYyNA==&amp;mid=2650918436&amp;idx=1&amp;sn=094e9c52fe922415a64297a18fcc1bb4&amp;chksm=84d4b243b3a33b55aa6bb99c495fe4156659c1ac1e0d8312b232054b51a26f041a32b4929f4a#rd</a></p>

<h3 id="第-91-天">第 91 天</h3>

<p>1.下面两段代码能否编译通过？请简要说明。</p>

<p>第一段：</p>

<pre><code class="language-GO">func f() {}
func f() {}

func main() {}
</code></pre>

<p>第二段：</p>

<pre><code class="language-go">func init(){}
func init(){}

func main() {}
</code></pre>

<p>参考答案及解析：第二段代码能通过编译。除 init() 函数之外，一个包内不允许有其他同名函数。</p>

<p>2.下面代码有什么问题？请指出。</p>

<pre><code class="language-go">func (m map[string]string) Set(key string, value string) {
	m[key] = value
}

func main() {
	m := make(map[string]string)
	m.Set(&quot;A&quot;, &quot;One&quot;)
}
</code></pre>

<p>参考答案及解析：Unnamed Type 不能作为方法的接收者。昨天我们讲过 Named Type 与 Unamed Type 的区别，就用 Named Type 来修复下代码：</p>

<pre><code class="language-go">type User map[string]string

func (m User) Set(key string, value string) {
	m[key] = value
}

func main() {
	m := make(User)
	m.Set(&quot;A&quot;, &quot;One&quot;)
}
</code></pre>

<h3 id="第-92-天">第 92 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">var x int

func init() {
	x++
}

func main() {
	init()
	fmt.Println(x)
}
</code></pre>

<p>参考答案及解析：编译失败。init() 函数不能被其他函数调用，包括 main() 函数。</p>

<p>2.min() 函数是求两个数之间的较小值，能否在 该函数中添加一行代码将其功能补全。</p>

<pre><code class="language-go">func min(a int, b uint) {
	var min = 0
	fmt.Printf(&quot;The min of %d and %d is %d\n&quot;, a, b, min)
}

func main() {
	min(1225, 256)
}
</code></pre>

<p>参考答案即解析：利用 copy() 函数的功能：切片复制，并且返回两者长度的较小值。</p>

<pre><code class="language-go">func min(a int, b uint) {
	var min = 0
	min = copy(make([]struct{},a),make([]struct{},b))
	fmt.Printf(&quot;The min of %d and %d is %d\n&quot;, a, b, min)
}

func main() {
	min(1225, 256)
}
</code></pre>

<h3 id="第-93-天">第 93 天</h3>

<p>1.关于 main() 函数，下面说法正确的是？</p>

<ul>
<li>不能带参数；</li>
<li>不能定义返回值；</li>
<li>所在的包必须为 main 包；</li>
<li>可以使用 flag 包来获取和解析命令行参数；</li>
</ul>

<p>参考答案及解析：ABCD。</p>

<p>2.下面代码能编译通过吗？请简要说明。</p>

<pre><code class="language-go">type User struct {
	Name string
}

func (u *User) SetName(name string) {
	u.Name = name
	fmt.Println(u.Name)
}

type Employee User

func main() {
	employee := new(Employee)
	employee.SetName(&quot;Jack&quot;)
}
</code></pre>

<p>参考答案及解析：编译不通过。当使用 type 声明一个新类型，它不会继承原有类型的方法集。</p>

<h3 id="第-94-天">第 94 天</h3>

<p>1.下面这段代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	a := 2 ^ 15
	b := 4 ^ 15
	if a &gt; b {
		println(&quot;a&quot;)
	} else {
		println(&quot;b&quot;)
	}
}
</code></pre>

<p>参考答案及解析：a。Go 语言里面 ^ 表示按位异或，而不是求幂。</p>

<pre><code class="language-go">0010 ^ 1111 == 1101   (2^15 == 13)
0100 ^ 1111 == 1011   (4^15 == 11)
</code></pre>

<p>2.下面哪些函数不能通过编译？</p>

<pre><code class="language-go">func A(string string) string {
	return string + string
}

func B(len int) int {
	return len + len
}

func C(val, default string) string {
	if val == &quot;&quot; {
		return default
	}
	return val
}
</code></pre>

<p>参考答案及解析：C() 函数不能通过编译。C() 函数的 default 属于关键字。string 和 len 是预定义标识符，可以在局部使用。nil 也可以当做变量使用，不过不建议写这样的代码，可读性不好，小心被接手你代码的人胖揍。</p>

<pre><code class="language-go">var nil = new(int)

func main() {
	var p *int
	if p == nil {
		fmt.Println(&quot;p is nil&quot;)
	} else {
		fmt.Println(&quot;p is not nil&quot;)
	}
}
</code></pre>

<h3 id="第-95-天">第 95 天</h3>

<p>1.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">type foo struct{ Val int }

type bar struct{ Val int }

func main() {
	a := &amp;foo{Val: 5}
	b := &amp;foo{Val: 5}
	c := foo{Val: 5}
	d := bar{Val: 5}
	e := bar{Val: 5}
	f := bar{Val: 5}
	fmt.Print(a == b, c == foo(d), e == f)
}
</code></pre>

<p>参考答案及解析：false true true。
这道题唯一有疑问的地方就在第一个比较，
Go 语言里没有引用变量，每个变量都占用一个惟一的内存位置，所以第一个比较输出 false。</p>

<p>2.下面代码输出什么？</p>

<pre><code class="language-go">func A() int {
	time.Sleep(100 * time.Millisecond)
	return 1
}

func B() int {
	time.Sleep(1000 * time.Millisecond)
	return 2
}

func main() {
	ch := make(chan int, 1)
	go func() {
		select {
		case ch &lt;- A():
		case ch &lt;- B():
		default:
			ch &lt;- 3
		}
	}()
	fmt.Println(&lt;-ch)
}
</code></pre>

<p>参考答案及解析：1、2随机输出。</p>

<h3 id="第-96-天">第 96 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">type Point struct{ x, y int }

func main() {
	s := []Point{
		{1, 2},
		{3, 4},
	}
	for _, p := range s {
		p.x, p.y = p.y, p.x
	}
	fmt.Println(s)
}
</code></pre>

<p>参考答案及解析：输出 [{1 2} {3 4}]。知识点：for range 循环。range 循环的时候，获取到的元素值是一个副本，就比如这里的 p。修复代码示例：</p>

<pre><code class="language-go">type Point struct{ x, y int }

func main() {
	s := []*Point{
		&amp;Point{1, 2},
		&amp;Point{3, 4},
	}
	for _, p := range s {
		p.x, p.y = p.y, p.x
	}
	fmt.Println(*s[0])
	fmt.Println(*s[1])
}
</code></pre>

<p>2.下面的代码有什么隐患？</p>

<pre><code class="language-go">func get() []byte {
	raw := make([]byte, 10000)
	fmt.Println(len(raw), cap(raw), &amp;raw[0])
	return raw[:3]
}

func main() {
	data := get()
	fmt.Println(len(data), cap(data), &amp;data[0])
}
</code></pre>

<p>参考答案及解析：get() 函数返回的切片与原切片公用底层数组，如果在调用函数里面（这里是 main() 函数）修改返回的切片，将会影响到原切片。为了避免掉入陷阱，可以如下修改：</p>

<pre><code class="language-go">func get() []byte {
	raw := make([]byte, 10000)
	fmt.Println(len(raw), cap(raw), &amp;raw[0])
	res := make([]byte, 3)
	copy(res, raw[:3])
	return res
}

func main() {
	data := get()
	fmt.Println(len(data), cap(data), &amp;data[0])
}
</code></pre>

<h3 id="第-97-天">第 97 天</h3>

<p>1.关于map，下面说法正确的是？</p>

<ul>
<li>A. map 反序列化时 json.unmarshal() 的入参必须为map的地址；</li>
<li>B. 在函数调用中传递 map，则子函数中对 map 元素的增加不会导致父函数中 map 的修改；</li>
<li>C. 在函数调用中传递 map，则子函数中对 map 元素的修改不会导致父函数中 map 的修改；</li>
<li>D. 不能使用内置函数 delete() 删除 map 的元素；</li>
</ul>

<p>参考答案及解析：A。知识点：map 的使用。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">type Foo struct {
	val int
}

func (f Foo) Inc(inc int) {
	f.val += inc
}

func main() {
	var f Foo
	f.Inc(100)
	fmt.Println(f.val)
}
</code></pre>

<p>参考答案及解析：输出 0。使用值类型接收者定义的方法，调用的时候，使用的是值的副本，对副本操作不会影响的原来的值。如果想要在调用函数中修改原值，可以使用指针接收者定义的方法。</p>

<pre><code class="language-go">type Foo struct {
	val int
}

func (f *Foo) Inc(inc int) {
	f.val += inc
}

func main() {
	f := &amp;Foo{}
	f.Inc(100)
	fmt.Println(f.val)  // 100
}
</code></pre>

<h3 id="第-98-天">第 98 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	a := 1
	for i := 0;i&lt;5;i++ {
		a := a + 1
		a = a * 2
	}
	fmt.Println(a)
}
</code></pre>

<p>参考答案及解析：1。知识点：变量的作用域。注意 for 语句的变量 a 是重新声明，它的作用范围只在 for 语句范围内。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">func test(i int) (ret int) {
	ret = i * 2
	if ret &gt; 10 {
		ret := 10
		return
	}
	return
}

func main() {
	result := test(10)
	fmt.Println(result)
}
</code></pre>

<p>参考答案即解析：编译错误。知识点：变量的作用域。编译错误信息：ret is shadowed during return。</p>

<h3 id="第-99-天">第 99 天</h3>

<p>1.下面代码能编译通过吗？</p>

<pre><code class="language-go">func main() {
	true := false
	fmt.Println(true)
}
</code></pre>

<p>参考答案即解析：编译通过。true 是预定义标识符可以用作变量名，但是不建议这么做。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">func watShadowDefer(i int) (ret int) {
	ret = i * 2
	if ret &gt; 10 {
		ret := 10
		defer func() {
			ret = ret + 1
		}()
	}
	return
}

func main() {
	result := watShadowDefer(50)
	fmt.Println(result)
}
</code></pre>

<p>参考答案即解析：100。知识点：变量作用域和defer 返回值。</p>

<h3 id="第-100-天">第 100 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	m := map[string]int{
		&quot;G&quot;: 7, &quot;A&quot;: 1,
		&quot;C&quot;: 3, &quot;E&quot;: 5,
		&quot;D&quot;: 4, &quot;B&quot;: 2,
		&quot;F&quot;: 6, &quot;I&quot;: 9,
		&quot;H&quot;: 8,
	}
	var order []string
	for k, _ := range m {
		order = append(order, k)
	}
	fmt.Println(order)
}
</code></pre>

<p>参考答案即解析：按字母无序输出。知识点：遍历 map 是无序的。</p>

<p>2.下面的代码有什么问题？</p>

<pre><code class="language-go">type UserAges struct {
	ages map[string]int
	sync.Mutex
}

func (ua *UserAges) Add(name string, age int) {
	ua.Lock()
	defer ua.Unlock()
	ua.ages[name] = age
}

func (ua *UserAges) Get(name string) int {
	if age, ok := ua.ages[name]; ok {
		return age
	}
	return -1
}

func main() {
	count := 1000
	gw := sync.WaitGroup{}
	gw.Add(count * 3)
	u := UserAges{ages: map[string]int{}}
	add := func(i int) {
		u.Add(fmt.Sprintf(&quot;user_%d&quot;, i), i)
		gw.Done()
	}
	for i := 0; i &lt; count; i++ {
		go add(i)
		go add(i)
	}
	for i := 0; i &lt; count; i++ {
		go func(i int) {
			defer gw.Done()
			u.Get(fmt.Sprintf(&quot;user_%d&quot;, i))
		}(i)
	}
	gw.Wait()
	fmt.Println(&quot;Done&quot;)
}
</code></pre>

<p>参考答案即解析：在执行 Get() 方法时可能报错。知识点：读写锁。虽然可以使用 sync.Mutex 做写锁，但是 map 是并发读写不安全的。map 属于引用类型，并发读写时多个协程是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系，会报错 “fatal error: concurrent map read and map write”。</p>

<p>有兴趣的同学可以尝试用 sync.RWMutex（读写锁）改进下程序。</p>

<p>引自：<a href="https://juejin.im/entry/5971bed66fb9a06bb21adf15">https://juejin.im/entry/5971bed66fb9a06bb21adf15</a></p>

<h3 id="第-101-天">第 101 天</h3>

<p>1.关于循环语句，下面说法正确的有？</p>

<ul>
<li>A. 循环语句既支持 for 关键字，也支持 while 和 do-while；</li>
<li>B. 关键字for的基本使用方法与C/C++中没有任何差异；</li>
<li>C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；</li>
<li>D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；</li>
</ul>

<p>参考答案及解析：CD。</p>

<p>引自：<a href="https://blog.csdn.net/fhd994603831/article/details/90648525">https://blog.csdn.net/fhd994603831/article/details/90648525</a></p>

<p>2.下面代码的功能是从小到大找出 17 和 38 的 3 个公倍数，请问下面的代码有什么问题？</p>

<pre><code class="language-go">var ch chan int = make(chan int)

func generate() {
	for i := 17; i &lt; 5000; i += 17 {
		ch &lt;- i
		time.Sleep(1 * time.Millisecond)
	}
	close(ch)
}

func main() {
	timeout := time.After(800 * time.Millisecond)
	go generate()
	found := 0
	for {
		select {
		case i, ok := &lt;-ch:
			if ok {
				if i%38 == 0 {
					fmt.Println(i, &quot;is a multiple of 17 and 38&quot;)
					found++
					if found == 3 {
						break
					}
				}
			} else {
				break
			}
		case &lt;-timeout:
			fmt.Println(&quot;timed out&quot;)
			break
		}
	}
	fmt.Println(&quot;The end&quot;)
}
</code></pre>

<p>参考答案即解析：break 会跳出 select 块，但不会跳出 for 循环。这算是一个比较容易掉的坑。可以使用 break label 特性或者 goto 功能解决这个问题，这里使用 break label 作个示例。</p>

<pre><code class="language-go">var ch chan int = make(chan int)

func generate() {
	for i := 17; i &lt; 5000; i += 17 {
		ch &lt;- i
		time.Sleep(1 * time.Millisecond)
	}
	close(ch)
}

func main() {
	timeout := time.After(800 * time.Millisecond)
	go generate()
	found := 0
	MAIN_LOOP:
	for {
		select {
		case i, ok := &lt;-ch:
			if ok {
				if i%38 == 0 {
					fmt.Println(i, &quot;is a multiple of 17 and 38&quot;)
					found++
					if found == 3 {
						break MAIN_LOOP
					}
				}
			} else {
				break MAIN_LOOP
			}
		case &lt;-timeout:
			fmt.Println(&quot;timed out&quot;)
			break MAIN_LOOP
		}
	}
	fmt.Println(&quot;The end&quot;)
}
</code></pre>

<h3 id="第-102-天">第 102 天</h3>

<p>1.ch := make(chan interface{}) 和 ch := make(chan interface{},1) 有什么区别？</p>

<p>参考答案及解析：第一个是声明无缓存通道，第二个是声明缓存为 1 的通道。无缓存通道需要一直有接收者接收数据，写操作才会继续，不然会一直阻塞；而缓冲为 1 则即使没有接收者也不会阻塞，因为缓冲大小是 1 ，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。注意这两者还是有区别的。</p>

<p>2.下面的代码输出什么？请简要说明。</p>

<pre><code class="language-go">var mu sync.Mutex
var chain string

func main() {
	chain = &quot;main&quot;
	A()
	fmt.Println(chain)
}
func A() {
	mu.Lock()
	defer mu.Unlock()
	chain = chain + &quot; --&gt; A&quot;
	B()
}

func B() {
	chain = chain + &quot; --&gt; B&quot;
	C()
}

func C() {
	mu.Lock()
	defer mu.Unlock()
	chain = chain + &quot; --&gt; C&quot;
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 main &ndash;&gt; A &ndash;&gt; B &ndash;&gt; C；</li>
<li>C. 输出 main；</li>
<li>D. fatal error；</li>
</ul>

<p>参考答案即解析：D。使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁。</p>

<p>引自博客《鸟窝》 <a href="https://colobu.com/">https://colobu.com/</a></p>

<h3 id="第-103-天">第 103 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	fmt.Println(doubleScore(0))    
	fmt.Println(doubleScore(20.0)) 
	fmt.Println(doubleScore(50.0)) 
}
func doubleScore(source float32) (score float32) {
	defer func() {
		if score &lt; 1 || score &gt;= 100 {
			score = source
		}
	}()
	return source * 2
}
</code></pre>

<p>参考答案及解析：输出 0 40 50。知识点：defer 语句与返回值。函数的 return value 不是原子操作，而是在编译器中分解为两部分：返回值赋值 和 return。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">var mu sync.RWMutex
var count int

func main() {
	go A()
	time.Sleep(2 * time.Second)
	mu.Lock()
	defer mu.Unlock()
	count++
	fmt.Println(count)
}
func A() {
	mu.RLock()
	defer mu.RUnlock()
	B()
}
func B() {
	time.Sleep(5 * time.Second)
	C()
}
func C() {
	mu.RLock()
	defer mu.RUnlock()
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 1；</li>
<li>C. 程序 hang 住；</li>
<li>D. fatal error；</li>
</ul>

<p>参考答案及解析：D。当写锁阻塞时，新的读锁是无法申请的（有效防止写锁饥饿），导致死锁。</p>

<h3 id="第-104-天">第 104 天</h3>

<p>1.关于同步锁，下面说法正确的是？</p>

<ul>
<li>A. 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖的等待，除非该 goroutine 释放这个 Mutex；</li>
<li>B. RWMutex 在读锁占用的情况下，会阻止写，但不阻止读；</li>
<li>C. RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占；</li>
<li>D. Lock() 操作需要保证有 Unlock() 或 RUnlock() 调用与之对应；</li>
</ul>

<p>参考答案及解析：ABC。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		time.Sleep(time.Millisecond)
		wg.Done()
		wg.Add(1)
	}()
	wg.Wait()
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 无输出，正常退出；</li>
<li>C. 程序 hang 住；</li>
<li>D. panic；</li>
</ul>

<p>参考答案及解析：D。WaitGroup 在调用 Wait() 之后不能再调用 Add() 方法的。</p>

<h3 id="第-105-天">第 105 天</h3>

<p>1.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">var c = make(chan int)
var a int

func f() {
	a = 1
	&lt;-c
}
func main() {
	go f()
	c &lt;- 0
	print(a)
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 1；</li>
<li>C. 输出 0；</li>
<li>D. panic；</li>
</ul>

<p>参考答案及解析：B。能正确输出，不过主协程会阻塞 f() 函数的执行。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">type MyMutex struct {
	count int
	sync.Mutex
}

func main() {
	var mu MyMutex
	mu.Lock()
	var mu1 = mu
	mu.count++
	mu.Unlock()
	mu1.Lock()
	mu1.count++
	mu1.Unlock()
	fmt.Println(mu.count, mu1.count)
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 1, 1；</li>
<li>C. 输出 1, 2；</li>
<li>D. fatal error；</li>
</ul>

<p>参考答案及解析：D。加锁后复制变量，会将锁的状态也复制，所以 mu1 其实是已经加锁状态，再加锁会死锁。</p>

<h3 id="第-106-天">第 106 天</h3>

<p>1.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	var ch chan int
	var count int
	go func() {
		ch &lt;- 1
	}()
	go func() {
		count++
		close(ch)
	}()
	&lt;-ch
	fmt.Println(count)
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 1；</li>
<li>C. 输出 0；</li>
<li>D. panic；</li>
</ul>

<p>参考答案及解析：D。ch 未有被初始化，关闭时会报错。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	var ch chan int
	go func() {
		ch = make(chan int, 1)
		ch &lt;- 1
	}()
	go func(ch chan int) {
		time.Sleep(time.Second)
		&lt;-ch
	}(ch)

	c := time.Tick(1 * time.Second)
	for range c {
		fmt.Printf(&quot;#goroutines: %d\n&quot;, runtime.NumGoroutine())
	}
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 一段时间后总是输出 #goroutines: 1；</li>
<li>C. 一段时间后总是输出 #goroutines: 2；</li>
<li>D. panic；</li>
</ul>

<p>参考答案即解析：C。程序执行到第二个 groutine 时，ch 还未初始化，导致第二个 goroutine 阻塞。需要注意的是第一个 goroutine 不会阻塞。</p>

<p>引自博客《鸟窝》 <a href="https://colobu.com/">https://colobu.com/</a></p>

<h3 id="第-107-天">第 107 天</h3>

<p>1.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	var m sync.Map
	m.LoadOrStore(&quot;a&quot;, 1)
	m.Delete(&quot;a&quot;)
	fmt.Println(m.Len())
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 1；</li>
<li>C. 输出 0；</li>
<li>D. panic；</li>
</ul>

<p>参考答案及解析：D。sync.Map 没有 Len() 方法。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	var wg sync.WaitGroup
	wg.Add(2)
	var ints = make([]int, 0, 1000)
	go func() {
		for i := 0; i &lt; 1000; i++ {
			ints = append(ints, i)
		}
		wg.Done()
	}()
	go func() {
		for i := 0; i &lt; 1000; i++ {
			ints = append(ints, i)
		}
		wg.Done()
	}()
	wg.Wait()
	fmt.Println(len(ints))
}
</code></pre>

<ul>
<li>A. 不能编译；</li>
<li>B. 输出 2000；</li>
<li>C. 输出可能不是 2000；</li>
<li>D. panic；</li>
</ul>

<p>参考答案及解析：C。append() 并不是并发安全的，有兴趣的同学可以尝试用锁去解决这个问题。</p>

<h3 id="第-108-天">第 108 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">type People struct {
	name string `json:&quot;name&quot;`
}

func main() {
	js := `{
		&quot;name&quot;:&quot;11&quot;
	}`
	var p People
	err := json.Unmarshal([]byte(js), &amp;p)
	if err != nil {
		fmt.Println(&quot;err: &quot;, err)
		return
	}
	fmt.Println(&quot;people: &quot;, p)
}
</code></pre>

<p>参考答案及解析：people:{}。按照 go 的语法，小写开头的方法、属性或 struct 是私有的，同样，在 json 解码或转码的时候也无法实现私有属性的转换。</p>

<p>这段代码是无法正常得到 People 的 name 值的。而且，私有属性 name 也不应该加 json 的标签。</p>

<p>2.补充 A、B 两处代码，实现程序能解析 ip 和 prot 参数，默认值是  0.0.0.0 和 8000。</p>

<pre><code class="language-go">var ip string
var port int

func init() {
	// A
	// B
}

func main() {
	flag.Parse()
	fmt.Printf(&quot;%s:%d&quot;, ip, port)
}
</code></pre>

<p>参考答案及解析：flag 包的使用。</p>

<pre><code class="language-go">var ip string
var port int

func init() {
	flag.StringVar(&amp;ip, &quot;ip&quot;, &quot;0.0.0.0&quot;, &quot;ip address&quot;)
	flag.IntVar(&amp;port, &quot;port&quot;, 8000, &quot;port number&quot;)
}

func main() {
	flag.Parse()
	fmt.Printf(&quot;%s:%d&quot;, ip, port)
}
</code></pre>

<h3 id="第-109-天">第 109 天</h3>

<p>1.下面代码有什么问题？</p>

<pre><code class="language-go">func main() {
	ch := make(chan int, 1000)
	go func() {
		for i := 0; i &lt; 10; i++ {
			ch &lt;- i
		}
	}()
	go func() {
		for {
			a, ok := &lt;-ch
			if !ok {
				fmt.Println(&quot;close&quot;)
				return
			}
			fmt.Println(&quot;a: &quot;, a)
		}
	}()
	close(ch)
	fmt.Println(&quot;ok&quot;)
	time.Sleep(time.Second * 20)
}
</code></pre>

<p>参考答案及解析：panic。协程开启还未来得及执行，chan 就已经 close() ，往已经关闭的 chan 写数据会 panic。</p>

<p>2.在 A 处添加一行代码实现 S 按升序排列。</p>

<pre><code class="language-go">type S struct {
	v int
}

func main() {
	s := []S{{1}, {3}, {5}, {2}}
	// A
	fmt.Printf(&quot;%#v&quot;, s)
}
</code></pre>

<p>参考答案及解析：可以考虑使用 sort.Slice()。</p>

<pre><code class="language-go">type S struct {
	v int
}

func main() {
	s := []S{{1}, {3}, {5}, {2}}
	sort.Slice(s, func(i, j int) bool { return s[i].v &lt; s[j].v })
	fmt.Printf(&quot;%#v&quot;, s)
}
</code></pre>

<h3 id="第-110-天">第 110 天</h3>

<p>1.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">type T struct {
	V int
}

func (t *T) Incr(wg *sync.WaitGroup) {
	t.V++
	wg.Done()
}
func (t *T) Print() {
	time.Sleep(1)
	fmt.Print(t.V)
}
func main() {
	var wg sync.WaitGroup
	wg.Add(10)
	var ts = make([]T, 10)
	for i := 0; i &lt; 10; i++ {
		ts[i] = T{i}
	}
	for _, t := range ts {
		go t.Incr(&amp;wg)
	}
	wg.Wait()
	for _, t := range ts {
		go t.Print()
	}
	time.Sleep(5 * time.Second)
}
</code></pre>

<ul>
<li>A. 输出 12345678910；</li>
<li>B. 输出 0123456789；</li>
<li>C. 输出 9999999999；</li>
<li>D. panic；</li>
</ul>

<p>参考答案及解析：C。这道题需要注意的一点是 for range 循环里的变量 t 是临时变量。</p>

<p>2.下面的代码可以随机输出大小写字母，尝试在 A 处添加一行代码使得字母先按大写再按小写的顺序输出。</p>

<pre><code class="language-go">const N = 26

func main() {
	const GOMAXPROCS = 1
	runtime.GOMAXPROCS(GOMAXPROCS)
	
	var wg sync.WaitGroup
	wg.Add(2 * N)
	for i := 0; i &lt; N; i++ {
		go func(i int) {
			defer wg.Done()
			// A
			runtime.Gosched()
			fmt.Printf(&quot;%c&quot;, 'a'+i)
		}(i)
		go func(i int) {
			defer wg.Done()
			fmt.Printf(&quot;%c&quot;, 'A'+i)
		}(i)
	}
	wg.Wait()
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">const N = 26

func main() {
	const GOMAXPROCS = 1
	runtime.GOMAXPROCS(GOMAXPROCS)

	var wg sync.WaitGroup
	wg.Add(2 * N)
	for i := 0; i &lt; N; i++ {
		go func(i int) {
			defer wg.Done()
			runtime.Gosched()
			fmt.Printf(&quot;%c&quot;, 'a'+i)
		}(i)
		go func(i int) {
			defer wg.Done()
			fmt.Printf(&quot;%c&quot;, 'A'+i)
		}(i)
	}
	wg.Wait()
}
</code></pre>

<h3 id="第-111-天">第 111 天</h3>

<p>1.下面两处打印的值是否相同？请简要说明。</p>

<pre><code class="language-go">func main() {
	var val int
	println(&amp;val)
	f(10000)
	println(&amp;val)
}

func f(i int) {
	if i--; i == 0 {
		return
	}
	f(i)
}
</code></pre>

<p>参考答案及解析：不同。知识点：栈增长、逃逸分析。每个 groutine 都会分配相应的栈内存，比如 Go 1.11 版本是 2Kb，随着程序运行，栈内存会发生增长或缩小，协程会重新申请栈内存块。就像这个题目，循环调用 f()，发生深度递归，栈内存不断增大，当超过范围时，会重新申请栈内存，所以 val 的地址会变化。</p>

<p>这道题还有个特别注意的地方，如果将 println() 函数换成 fmt.Println() 会发现，打印结果相同。为什么？因为函数 fmt.Println() 使变量 val 发生了逃逸，逃逸到堆内存，即使协程栈内存重新申请，val 变量在堆内存的地址也不会改变。</p>

<p>2.下面代码 A 处输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	var val int

	a := &amp;val
	println(a)
	
	f(10000)
	
	b := &amp;val
	println(b)

	println(a == b)  // A
}

func f(i int) {
	if i--; i == 0 {
		return
	}
	f(i)
}
</code></pre>

<ul>
<li>A. ture</li>
<li>B. false</li>
</ul>

<p>参考答案及解析：A。这道题和上一道有一定联系，a 是指向变量 val 的指针，我们知道 val 变量的地址发生了改变，a 指向 val 新的地址是由内存管理自动实现的。</p>

<pre><code class="language-go">func main() {
	var val int

	a := &amp;val
	println(a)

	f(10000)

	b := &amp;val
	println(a)   // a b 的值相同
	println(b)

	println(a == b) // A
}

func f(i int) {
	if i--; i == 0 {
		return
	}
	f(i)
}
</code></pre>

<p>来源：<a href="https://twitter.com/empijei/status/1206718810025267200">https://twitter.com/empijei/status/1206718810025267200</a></p>

<p>相关阅读:<br>
<a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoPointerToInteger">https://utcc.utoronto.ca/~cks/space/blog/programming/GoPointerToInteger</a><br>
<a href="https://blog.cloudflare.com/how-stacks-are-handled-in-go/amp/">https://blog.cloudflare.com/how-stacks-are-handled-in-go/amp/</a></p>

<h3 id="第-112-天">第 112 天</h3>

<p>1.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	x := []int{100, 200, 300, 400, 500, 600, 700}
	twohundred := &amp;x[1]
	x = append(x, 800)
	for i := range x {
		x[i]++
	}
	fmt.Println(*twohundred)
}
</code></pre>

<p>参考答案及解析：200。因为原切片的容量已经满了，执行 append 操作之后会创建一个新的底层数组，并将原切片底层数组的值拷贝到新的数组，原数组保持不变。</p>

<pre><code class="language-go">func main() {

	x := make([]int, 0, 7)
	x = append(x, 100, 200, 300, 400, 500, 600, 700)
	twohundred := &amp;x[1]
	x = append(x, 800)
	for i := range x {
		x[i]++
	}
	fmt.Println(*twohundred)    // 输出 200

	x = make([]int, 0, 8)   // 指向另一个切片
	x = append(x, 100, 200, 300, 400, 500, 600, 700)
	twohundred = &amp;x[1]
	x = append(x, 800)  // 执行 append 操作，容量足够，不会重新申请内存
	for i := range x {
		x[i]++
	}
	fmt.Println(*twohundred)  // 输出 201
}

</code></pre>

<p>2.下面的代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	a := []int{0, 1}
	fmt.Printf(&quot;%v&quot;, a[len(a):])
}
</code></pre>

<p>参考答案及解析：输出 []。对一个切片执行 [i,j] 的时候，i 和 j 都不能超过切片的长度值。</p>

<h3 id="第-113-天">第 113 天</h3>

<p>1.关于 const 常量定义，下面正确的使用方式是？</p>

<p>A.</p>

<pre><code class="language-go">const Pi float64 = 3.14159265358979323846
const zero= 0.0
</code></pre>

<p>B.</p>

<pre><code class="language-go">const (
	size int64= 1024
	eof = -1
)
</code></pre>

<p>C.</p>

<pre><code class="language-go">const (
	ERR_ELEM_EXISTerror = errors.New(&quot;element already exists&quot;)
	ERR_ELEM_NT_EXISTerror = errors.New(&quot;element not exists&quot;)
)
</code></pre>

<p>D.</p>

<pre><code class="language-go">const u, vfloat32 = 0, 3
const a,b, c = 3, 4, &quot;foo&quot;
</code></pre>

<p>参考答案及解析：ABD。</p>

<p>2.修改下面的代码，使得第二个输出 [seek 1 2 3 4] 。</p>

<pre><code class="language-go">func link(p ...interface{}) {
	fmt.Println(p)
}

func main() {
	link(&quot;seek&quot;, 1, 2, 3, 4) // 输出 [seek 1 2 3 4] 
	a := []int{1, 2, 3, 4}
	link(&quot;seek&quot;, a) // 输出 [seek [1 2 3 4]] 
}
</code></pre>

<p>参考答案及解析：</p>

<pre><code class="language-go">func link(p ...interface{}) {
	fmt.Println(p)
}

func main() {
	link(&quot;seek&quot;, 1, 2, 3, 4) // 输出 [seek 1 2 3 4]
	a := []int{1, 2, 3, 4}
	link(&quot;seek&quot;, a) // 输出 [seek [1 2 3 4]]

	tmplink := make([]interface{}, 0, len(a)+1)
	tmplink = append(tmplink, &quot;seek&quot;)
	for _, ii := range a {
		tmplink = append(tmplink, ii)
	}
	link(tmplink...) // 输出 [seek 1 2 3 4]
}
</code></pre>

<h3 id="第-114-天">第 114 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	ns := []int{010: 200, 005: 100}
	print(len(ns))
}
</code></pre>

<p>参考答案及解析：9。Go 语言中，0x 开头表示 十六进制；0 开头表示八进制。</p>

<p>2.下面的代码输出什么？请简要说明。</p>

<pre><code class="language-go">func main() {
	i := 0
	f := func() int {
		i++
		return i
	}
	c := make(chan int, 1)
	c &lt;- f()
	select {
	case c &lt;- f():
	default:
		fmt.Println(i)
	}
}
</code></pre>

<p>参考答案即解析：2。知识点：select 的使用。</p>

<p>下面这段代码会更有助于大家理解：</p>

<pre><code class="language-go">func main() {
	i := 0
	f := func() int {
		fmt.Println(&quot;incr&quot;)
		i++
		return i
	}
	c := make(chan int)
	for j := 0; j &lt; 2; j++ {
		select {
		case c &lt;- f():
			// noop
		default:
			// noop
		}
	}
	fmt.Println(i)
}
</code></pre>

<h3 id="第-115-天">第 115 天</h3>

<p>1.下面正确的是？</p>

<pre><code class="language-go">var y int

func f(x int) int {
	return 7
}

A.
switch y = f(2) {
case y == 7:
  return
}

B.
switch y = f(2); {
case y == 7:
  return
}

C.
switch y = f(2) {
case 7:
  return
}

D.
switch y = f(2); {
case 7:
  return
}
</code></pre>

<p>参考答案及解析：B。知识点：switch case 的使用。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">func main() {
	a := []int{1, 2, 3, 4}
	b := variadic(a...)
	b[0], b[1] = b[1], b[0]
	fmt.Println(a)
}

func variadic(ints ...int) []int {
	return ints
}
</code></pre>

<p>参考答案及解析：2 1 3 4。知识点：可变函数。切片作为参数传入可变函数时不会创建新的切片。</p>

<h3 id="第-116-天">第 116 天</h3>

<p>1.下面的代码输出什么？</p>

<pre><code class="language-go">const (
    one = 1 &lt;&lt; iota
    two
)

func main() {
    fmt.Println(one, two)
}
</code></pre>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">const (
	greeting = &quot;Hello, Go&quot;
	one = 1 &lt;&lt; iota
	two
)

func main() {
	fmt.Println(one, two)
}
</code></pre>

<p>参考答案及解析： 这两道题考的是同一个知识点：iota 的使用。
第一题：1 2；第二题：2，4。</p>

<h3 id="第-117-天">第 117 天</h3>

<p>1.Go 语言中中大多数数据类型都可以转化为有效的JSON文本，下面几种类型除外。</p>

<ul>
<li>A. 指针</li>
<li>B. channel</li>
<li>C. complex</li>
<li>D. 函数</li>
</ul>

<p>参考答案及解析：BCD。</p>

<p>2.下面代码输出什么？如果想要代码输出 10，应该如何修改？</p>

<pre><code class="language-go">const N = 10

func main() {
	m := make(map[int]int)

	wg := &amp;sync.WaitGroup{}
	mu := &amp;sync.Mutex{}
	wg.Add(N)
	for i := 0; i &lt; N; i++ {
		go func() {
			defer wg.Done()
			mu.Lock()
			m[i] = i
			mu.Unlock()
		}()
	}
	wg.Wait()
	println(len(m))
}
</code></pre>

<p>参考答案及解析：输出 1。知识点：并发、引用。修复代码如下：</p>

<pre><code class="language-go">const N = 10

func main() {
	m := make(map[int]int)

	wg := &amp;sync.WaitGroup{}
	mu := &amp;sync.Mutex{}
	wg.Add(N)
	for i := 0; i &lt; N; i++ {
		go func(i int) {
			defer wg.Done()
			mu.Lock()
			m[i] = i
			mu.Unlock()
		}(i)
	}
	wg.Wait()
	println(len(m))
}
</code></pre>

<h3 id="第-118-天">第 118 天</h3>

<p>1、下面说法正确的是。</p>

<ul>
<li>A. Go 语言中，声明的常量未使用会报错；</li>
<li>B. cap() 函数适用于 array、slice、map 和 channel;</li>
<li>C. 空指针解析会触发异常；</li>
<li>D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值；</li>
</ul>

<p>参考答案及解析：CD。A.不会报错；B.cap() 函数不适用 map。</p>

<p>2.下面的代码输出什么？</p>

<pre><code class="language-go">const (
    _ = iota
    c1 int = (10*iota)
    c2
    d = iota
)
func main() {
  fmt.Printf(&quot;%d - %d - %d&quot;,c1,c2, d)
}
</code></pre>

<ul>
<li>A. compile error</li>
<li>B. 1 - 2 - 3</li>
<li>C. 10 - 20 - 30</li>
<li>D. 10 - 20 - 3</li>
</ul>

<p>参考答案及解析：D。iota 的使用。</p>

<p>相关阅读：<br>
<a href="https://twitter.com/gopherconf/status/1205451736678371328">https://twitter.com/gopherconf/status/1205451736678371328</a><br>
<a href="https://github.com/golang/go/wiki/Iota">https://github.com/golang/go/wiki/Iota</a></p>

<h3 id="第-119-天">第 119 天</h3>

<p>1.关于slice或map操作，下面正确的是。</p>

<p>A.</p>

<pre><code class="language-go">var s []int
s = append(s,1)
</code></pre>

<p>B.</p>

<pre><code class="language-go">var m map[string]int
m[&quot;one&quot;] = 1 
</code></pre>

<p>C.</p>

<pre><code class="language-go">var s []int
s = make([]int, 0)
s = append(s,1)
</code></pre>

<p>D.</p>

<pre><code class="language-go">var m map[string]int
m = make(map[string]int)
m[&quot;one&quot;] = 1 
</code></pre>

<p>参考答案及解析：ACD。</p>

<p>2.下面代码输出什么？请简要说明。</p>

<pre><code class="language-go">var ErrDidNotWork = errors.New(&quot;did not work&quot;)

func DoTheThing(reallyDoIt bool) (err error) {
	if reallyDoIt {
		result, err := tryTheThing()
		if err != nil || result != &quot;it worked&quot; {
			err = ErrDidNotWork
		}
	}
	return err
}

func tryTheThing() (string, error) {
	return &quot;&quot;, ErrDidNotWork
}

func main() {
	fmt.Println(DoTheThing(true))
	fmt.Println(DoTheThing(false))
}
</code></pre>

<p>参考答案即解析：都输出 nil。知识点：变量的作用域。因为 if 语句块内的 err 变量会遮罩函数作用域内的 err 变量。</p>

<p>修复代码：</p>

<pre><code class="language-go">func DoTheThing(reallyDoIt bool) (err error) {
	var result string
	if reallyDoIt {
		result, err = tryTheThing()
		if err != nil || result != &quot;it worked&quot; {
			err = ErrDidNotWork
		}
	}
	return err
}
</code></pre>

<h3 id="第-120-天">第 120 天</h3>

<p>1.下面代码输出什么？</p>

<pre><code class="language-go">func main() {
	fmt.Println(len(&quot;你好bj!&quot;))
}
</code></pre>

<p>参考答案及解析：9。知识点：编码长度。</p>

<p>2.是否可以编译通过？如果通过，输出什么？</p>

<pre><code class="language-go">func GetValue(m map[int]string, id int) (string, bool) {
	if _, exist := m[id]; exist {
		return &quot;存在数据&quot;, true
	}
	return nil, false
}

func main() {

	intmap := map[int]string{
		1: &quot;a&quot;,
		2: &quot;bb&quot;,
		3: &quot;ccc&quot;,
	}

	v, err := GetValue(intmap, 3)
	fmt.Println(v, err)
}
</code></pre>

<p>参考答案及解析：函数返回值类型 nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错。通常编译的时候不会报错，但是运行是时候会报:cannot use nil as type string in return argument.</p>

<p>引自《Go夜读》</p>

<p><br><br>
(全文完)
<img src="/me/weixingzh.jpg" alt="" /></p>

<h4 id="center-扫码关注领取学习资料-center"><center>扫码关注领取学习资料！</center></h4>

                        </div>

                        

<div class="post-archive">
    <h3>推荐阅读</h3>
    <ul class="listing">
        
        <li><a href="/2021/02/09/understanding-the-context-package.html">掌握 Context 包</a></li>
        
        <li><a href="/2021/02/06/using-context-cancellation.html">使用 Go 语言 context 包的取消功能</a></li>
        
        <li><a href="/2019/08/31/go-interview-9-day.html">Go面试每天一篇（第 9 天）</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://seekload.net/tags/go">Go</a></li>
                                
                                <li><a href="https://seekload.net/tags/golang">Golang</a></li>
                                
                                <li><a href="https://seekload.net/tags/%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "Seekload/Seekload.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
                </div>
            </div>
            <div id="secondary">

    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://seekload.net">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利!!扫码关注领取学习资料！</h3>
    <ul class="widget-list">
        
        <li>
            <a title=""  style="color:red">
                
                    <img src="/me/weixingzh.jpg">
                
            </a>
        </li>
        
    </ul>
</section>

    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://seekload.net/2021/02/28/interview-question.html" title="Golang语言面试题（精编263道题），包含解析！！！">Golang语言面试题（精编263道题），包含解析！！！</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2021/02/09/understanding-the-context-package.html" title="掌握 Context 包">掌握 Context 包</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2021/02/06/using-context-cancellation.html" title="使用 Go 语言 context 包的取消功能">使用 Go 语言 context 包的取消功能</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/31/go-interview-9-day.html" title="Go面试每天一篇（第 9 天）">Go面试每天一篇（第 9 天）</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/31/go-pointers-vs-references.html" title="指针与引用（译）">指针与引用（译）</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/30/go-interview-8-day.html" title="Go面试每天一篇（第 8 天）">Go面试每天一篇（第 8 天）</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/29/go-interview-7-day.html" title="Go面试每天一篇（第 7 天）">Go面试每天一篇（第 7 天）</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/28/go-interview-6-day.html" title="Go面试每天一篇（第 6 天）">Go面试每天一篇（第 6 天）</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/27/go-interview-5-day.html" title="Go面试每天一篇（第 5 天）">Go面试每天一篇（第 5 天）</a>
    </li>
    
    <li>
        <a href="https://seekload.net/2019/08/26/go-interview-4-day.html" title="Go面试每天一篇（第 4 天）">Go面试每天一篇（第 4 天）</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://niannian.cleer.club/" title="念念有鱼">念念有鱼</a>
        </li>
        
    </ul>
</section>


    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://seekload.net/categories/golang/">Golang(38)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/go%E9%9D%A2%E8%AF%95%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%AF%87/">Go面试每天一篇(9)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E5%86%99%E4%BD%9C/">写作(1)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E5%B0%B1%E8%A6%81%E5%AD%A6%E4%B9%A0-go-%E8%AF%AD%E8%A8%80/">就要学习 Go 语言(26)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E6%80%9D%E7%BB%B4/">思维(1)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E6%B4%BB%E5%8A%A8/">活动(1)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E8%AE%A4%E7%9F%A5/">认知(1)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E8%AF%BB%E4%B9%A6/">读书(1)</a>
    </li>
    
    <li>
        <a href="https://seekload.net/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题(1)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://seekload.net/tags/go/">Go</a>
    
    <a href="https://seekload.net/tags/golang/">Golang</a>
    
    <a href="https://seekload.net/tags/map/">Map</a>
    
    <a href="https://seekload.net/tags/oop/">OOP</a>
    
    <a href="https://seekload.net/tags/channel/">channel</a>
    
    <a href="https://seekload.net/tags/context/">context</a>
    
    <a href="https://seekload.net/tags/function/">function</a>
    
    <a href="https://seekload.net/tags/select/">select</a>
    
    <a href="https://seekload.net/tags/variadic/">variadic</a>
    
    <a href="https://seekload.net/tags/%E4%BF%A1%E9%81%93/">信道</a>
    
    <a href="https://seekload.net/tags/%E5%86%99%E4%BD%9C/">写作</a>
    
    <a href="https://seekload.net/tags/%E5%87%BD%E6%95%B0/">函数</a>
    
    <a href="https://seekload.net/tags/%E5%88%87%E7%89%87/">切片</a>
    
    <a href="https://seekload.net/tags/%E5%8C%85/">包</a>
    
    <a href="https://seekload.net/tags/%E5%8D%8F%E7%A8%8B/">协程</a>
    
    <a href="https://seekload.net/tags/%E5%8F%98%E9%87%8F/">变量</a>
    
    <a href="https://seekload.net/tags/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0/">可变函数</a>
    
    <a href="https://seekload.net/tags/%E5%9D%9A%E6%8C%81/">坚持</a>
    
    <a href="https://seekload.net/tags/%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/">工作空间</a>
    
    <a href="https://seekload.net/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="https://seekload.net/tags/%E5%BC%95%E7%94%A8/">引用</a>
    
    <a href="https://seekload.net/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B/">影响力</a>
    
    <a href="https://seekload.net/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/">循环语句</a>
    
    <a href="https://seekload.net/tags/%E6%80%9D%E7%BB%B4/">思维</a>
    
    <a href="https://seekload.net/tags/%E6%8C%87%E9%92%88/">指针</a>
    
    <a href="https://seekload.net/tags/%E6%8E%A5%E5%8F%A3/">接口</a>
    
    <a href="https://seekload.net/tags/%E6%95%B0%E7%BB%84/">数组</a>
    
    <a href="https://seekload.net/tags/%E6%96%B9%E6%B3%95/">方法</a>
    
    <a href="https://seekload.net/tags/%E6%98%A0%E5%B0%84/">映射</a>
    
    <a href="https://seekload.net/tags/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/">条件语句</a>
    
    <a href="https://seekload.net/tags/%E7%B1%BB%E5%9E%8B/">类型</a>
    
    <a href="https://seekload.net/tags/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>
    
    <a href="https://seekload.net/tags/%E8%AE%A4%E7%9F%A5/">认知</a>
    
    <a href="https://seekload.net/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
    
    <a href="https://seekload.net/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符</a>
    
    <a href="https://seekload.net/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
    
    <a href="https://seekload.net/tags/%E9%9D%A2%E5%9F%BA/">面基</a>
    
    <a href="https://seekload.net/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
    <a href="https://seekload.net/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
    
</div>
    </section>

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://seekload.net/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        
        &copy; 2021 <a href="https://seekload.net"> 公众号：Golang来啦 </a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-133344385-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>
</html>
